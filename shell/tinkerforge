#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (C) 2013-2014 Matthias Bolte <matthias@tinkerforge.com>
#
# Version 2.1.4
#
# Redistribution and use in source and binary forms of this file,
# with or without modification, are permitted. See the Creative
# Commons Zero (CC0 1.0) License for more details.

import sys
import os
import signal
import time
import shlex
import socket
import select
import threading
import subprocess
import textwrap

# error codes are also used as exit codes, valid values are [1..255]
ERROR_INTERRUPTED = 1
ERROR_SYNTAX_ERROR = 2
ERROR_PYTHON_VERSION = 21
ERROR_ARGPARSE_MISSING = 22
ERROR_SOCKET_ERROR = 23
ERROR_OTHER_EXCEPTION = 24
ERROR_INVALID_PLACEHOLDER = 25
ERROR_AUTHENTICATION_ERROR = 26
IPCONNECTION_ERROR_OFFSET = 200

listen_mode = False
enable_host = True
enable_port = True
enable_execute = True
line_separator = '\n'
group_terminator = '\n'

# set from environment variable
dry_run = False

def fatal_error(message, exit_code):
	sys.stderr.write('tinkerforge: error: {0}\n'.format(message))
	sys.exit(exit_code)

if sys.hexversion < 0x02050000:
	fatal_error('requiring python 2.5 or newer', ERROR_PYTHON_VERSION)

try:
	import argparse
except ImportError:
	fatal_error('requiring python argparse module', ERROR_ARGPARSE_MISSING)

class Context:
	abort = False
	async_exception = None

	host = None
	port = None
	secret = None
	item_separator = None
	group_separator = None
	no_symbolic_input = None
	no_symbolic_output = None
	timeout = None
	duration = None
	uid = None

	def output(self, string):
		sys.stdout.write(string)

	def duplicate(self):
		ctx = Context()

		ctx.host = self.host
		ctx.port = self.port
		ctx.secret = self.secret
		ctx.item_separator = self.item_separator
		ctx.group_separator = self.group_separator
		ctx.no_symbolic_input = self.no_symbolic_input
		ctx.no_symbolic_output = self.no_symbolic_output
		ctx.timeout = self.timeout
		ctx.duration = self.duration
		ctx.uid = self.uid

		return ctx

class ParserExit(Exception):
	pass

class FatalError(Exception):
	def __init__(self, message, exit_code):
		Exception.__init__(self, message)

		self.exit_code = exit_code
		self.message = message

class Formatter(argparse.HelpFormatter):
	def _fill_text(self, text, width, indent):
		ps = []

		for p in text.split('\n'):
			ps.append(textwrap.fill(p, width, initial_indent=indent, subsequent_indent=indent))

		return '\n'.join(ps)

class Parser(argparse.ArgumentParser):
	def __init__(self, ctx, prog, description=None, epilog=None):
		if not listen_mode:
			if len(prog) > 0:
				prog = 'tinkerforge ' + prog
			else:
				prog = 'tinkerforge'

		argparse.ArgumentParser.__init__(self, prog=prog, add_help=False, description=description, epilog=epilog, formatter_class=Formatter)

		self.ctx = ctx
		self.ctx.current_parser = self

		self.add_argument('--help', action='help', help='show this help message and exit')

	def _print_message(self, message, file=None):
		if message:
			self.ctx.output(message)

	def exit(self, status=0, message=None):
		if status == 0:
			if message:
				self.ctx.output(message)

			raise ParserExit
		else:
			if not message:
				message = 'unknown error'

			raise FatalError(message, ERROR_OTHER_EXCEPTION)

	def error(self, message):
		if not listen_mode:
			self.print_usage(sys.stderr)

		raise FatalError(message, ERROR_SYNTAX_ERROR)

class ParserWithExecute(Parser):
	def __init__(self, ctx, prog):
		Parser.__init__(self, ctx, prog)

		if enable_execute:
			self.add_argument('--execute', type=str, help='shell command line to execute for each incoming response', metavar='<command>')

	def parse_args(self, args):
		namespace = argparse.Namespace()

		if not enable_execute:
			setattr(namespace, 'execute', None)

		return Parser.parse_args(self, args, namespace)

class ParserWithExpectResponse(Parser):
	def __init__(self, ctx, prog):
		Parser.__init__(self, ctx, prog)

		self.add_argument('--expect-response', action='store_true', help='request response and wait for it')

def handle_ipcon_exceptions(ipcon, function):
	try:
		function(ipcon)
	except Error as e:
		raise FatalError(e.description.lower(), IPCONNECTION_ERROR_OFFSET - e.value)
	except socket.error as e:
		raise FatalError(str(e).lower(), ERROR_SOCKET_ERROR)
	except Exception as e:
		raise FatalError(str(e).lower(), ERROR_OTHER_EXCEPTION)
	finally:
		try:
			ipcon.disconnect()
		except:
			pass

def authenticate(ipcon, secret, message):
	# don't auto-reconnect on authentication error
	ipcon.set_auto_reconnect(False)

	try:
		ipcon.authenticate(secret)
	except:
		raise FatalError(message, ERROR_AUTHENTICATION_ERROR)

	ipcon.set_auto_reconnect(True)

def connect_ipcon_and_call(ctx, function, timeout=None):
	def function_wrapper(ipcon):
		if timeout is not None:
			ipcon.set_timeout(timeout)

		ipcon.connect(ctx.host, ctx.port)

		if len(ctx.secret) > 0:
			def callback(connect_reason):
				if connect_reason == IPConnection.CONNECT_REASON_AUTO_RECONNECT:
					try:
						authenticate(ipcon, ctx.secret, 'could not authenticate after auto-reconnect')
					except FatalError as e:
						ctx.async_exception = e

			ipcon.register_callback(IPConnection.CALLBACK_CONNECTED, callback)
			authenticate(ipcon, ctx.secret, 'could not authenticate')

		function(ipcon)

	handle_ipcon_exceptions(IPConnection(), function_wrapper)

def call_generic(ctx, name, functions, argv):
	parser = Parser(ctx, 'call ' + name)
	function_choices = sorted(functions.keys())

	class ListFunctionsAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(function_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-functions', action=ListFunctionsAction, nargs=0, help='show functions of {0} and exit'.format(name))
	parser.add_argument('uid', type=check_base58, help='uid of a ' + name, metavar='<uid>')
	parser.add_argument('function', choices=function_choices, help='{' + ', '.join(function_choices) + '}', metavar='<function>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='function specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.uid = args.uid

	functions[args.function](ctx, args.args)

def dispatch_generic(ctx, name, callbacks, argv):
	parser = Parser(ctx, 'dispatch ' + name)
	callback_choices = sorted(callbacks.keys())

	class ListCallbacksAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(callback_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-callbacks', action=ListCallbacksAction, nargs=0, help='show callbacks of {0} and exit'.format(name))
	parser.add_argument('uid', type=check_base58, help='uid of a ' + name, metavar='<uid>')
	parser.add_argument('callback', choices=callback_choices, help='{' + ', '.join(callback_choices) + '}', metavar='<callback>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='callback specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.uid = args.uid

	callbacks[args.callback](ctx, args.args)

def device_send_request(ctx, device_class, function_id, request_data, format_in,
                        format_out, command, expect_response, names, symbols):
	if dry_run:
		return

	if command is not None:
		def handle_response(values):
			execute_response(ctx, command, names, values)
	else:
		def handle_response(values):
			output_response(ctx, names, values)

	def function(ipcon):
		device = device_class(ctx.uid, ipcon)

		if expect_response:
			device.set_response_expected(function_id, True)

		response = ipcon.send_request(device, function_id, request_data, format_in, format_out)

		if response is not None:
			if len(names) == 1:
				response = (response,)

			response = format_symbolic_output(ctx, response, symbols)

			handle_response(response)
		elif listen_mode:
			ctx.output(group_terminator)

	connect_ipcon_and_call(ctx, function, ctx.timeout / 1000.0)

def device_callback(ctx, device_class, function_id, command, names):
	if dry_run:
		return

	if command is not None:
		def callback(*values):
			execute_response(ctx, command, names, values)
	else:
		is_first_callback = [True]

		def callback(*values):
			if len(names) > 1 and not listen_mode:
				if is_first_callback[0]:
					is_first_callback[0] = False
				else:
					ctx.output(ctx.group_separator)

			output_response(ctx, names, values)

	def function(ipcon):
		device = device_class(ctx.uid, ipcon)

		if ctx.duration == 0:
			exit_flag = [False]

			def callback_wrapper(*args, **kwargs):
				if not exit_flag[0]:
					callback(*args, **kwargs)
					exit_flag[0] = True

			device.registered_callbacks[function_id] = callback_wrapper

			while not exit_flag[0] and not ctx.abort:
				time.sleep(0.1)

				if ctx.async_exception is not None:
					raise ctx.async_exception
		elif ctx.duration < 0:
			device.registered_callbacks[function_id] = callback

			while not ctx.abort:
				time.sleep(1)

				if ctx.async_exception is not None:
					raise ctx.async_exception
		else:
			device.registered_callbacks[function_id] = callback

			# FIXME: if duration is large then it would be better to sleep
			#        in multiple steps here
			time.sleep(ctx.duration / 1000.0)

			# FIXME: only checking for an exception after the complete sleep
			#        is not good, sleep in shorter steps here to check for
			#        exception more often
			if ctx.async_exception is not None:
				raise ctx.async_exception

	connect_ipcon_and_call(ctx, function)

# length_is_fixed = False means length is maximum length
def get_array_type_name(ctx, name, length, length_is_fixed=True):
	if length_is_fixed:
		if length < 7:
			return ctx.item_separator.join([name]*length)
		else:
			return '{0}{1}{0}{1}..{2}x..{1}{0}{1}{0}'.format(name, ctx.item_separator, length - 4)
	else:
		return ('[' + ctx.item_separator).join([name]*length) + ']'*(length - 1)

def format_symbolic_output(ctx, values, symbols):
	if ctx.no_symbolic_output:
		return values

	translated_values = []

	for vs in zip(values, symbols):
		if vs[1] is not None:
			try:
				translated_values.append(vs[1][vs[0]])
			except KeyError:
				translated_values.append(vs[0])
		else:
			translated_values.append(vs[0])

	return tuple(translated_values)

def check_base58(string):
	try:
		base58decode(string)
	except:
		msg = 'invalid base58 value: %r' % string
		raise argparse.ArgumentTypeError(msg)

	return string

check_base58.__name__ = 'base58'

def check_char(string):
	if len(string) != 1:
		msg = 'invalid char value: %r' % string
		raise argparse.ArgumentTypeError(msg)

	return string

check_char.__name__ = 'char'

def convert_int(string):
	try:
		return int(string, base=0)
	except (ValueError, TypeError):
		msg = 'invalid int value: %r' % string
		raise argparse.ArgumentTypeError(msg)

convert_int.__name__ = 'int'

def convert_bool(string):
	value = string.lower()

	if value == 'true':
		return True
	elif value == 'false':
		return False
	else:
		msg = 'invalid bool value: %r' % string
		raise argparse.ArgumentTypeError(msg)

convert_bool.__name__ = 'bool'

def create_string_checker(type, length):
	def check_string(string):
		try:
			value = type(string)
		except (ValueError, TypeError):
			name = getattr(type, '__name__', repr(type))
			msg = 'invalid %s value: %r' % (name, string)
			raise argparse.ArgumentTypeError(msg)

		if len(value) > length:
			msg = 'string value is too long: %r' % value
			raise argparse.ArgumentTypeError(msg)

		return value

	check_string.__name__ = 'string'

	return check_string

def create_symbol_converter(ctx, type, symbols, strict=False):
	def convert_symbol(string):
		if not ctx.no_symbolic_input:
			try:
				return symbols[string]
			except KeyError:
				pass

		try:
			value = type(string)
		except (ValueError, TypeError):
			name = getattr(type, '__name__', repr(type))
			msg = 'invalid %s value: %r' % (name, string)
			raise argparse.ArgumentTypeError(msg)

		if strict and value not in symbols.values():
			name = getattr(type, '__name__', repr(type))
			msg = '%s value is out-of-range: %r' % (name, string)
			raise argparse.ArgumentTypeError(msg)

		return value

	convert_symbol.__name__ = getattr(type, '__name__', repr(type))

	return convert_symbol

# length_is_fixed = False means length is maximum length
def create_array_converter(ctx, type, length, length_is_fixed=True):
	def convert_array(string):
		array = []

		for item in string.split(ctx.item_separator):
			try:
				value = type(item)
			except (ValueError, TypeError, argparse.ArgumentTypeError):
				name = getattr(type, '__name__', repr(type))
				msg = 'invalid %s value: %r' % (get_array_type_name(ctx, name, length, length_is_fixed), string)
				raise argparse.ArgumentTypeError(msg)

			array.append(value)

		if (length_is_fixed and len(array) != length) or \
		   (not length_is_fixed and (len(array) < 1 or len(array) > length)):
			name = getattr(type, '__name__', repr(type))
			msg = 'invalid %s value: %r' % (get_array_type_name(ctx, name, length, length_is_fixed), string)
			raise argparse.ArgumentTypeError(msg)

		return array

	name = getattr(type, '__name__', repr(type))
	convert_array.__name__ = get_array_type_name(ctx, name, length, length_is_fixed)

	return convert_array

def execute_response(ctx, command, names, values):
	formatted_values = {}

	class Tuple(tuple):
		def __init__(self, *args):
			tuple.__init__(self, *args)

		def __str__(self):
			return ctx.item_separator.join(map(str, self))

	for name, value in zip(names, values):
		if type(value) == tuple:
			formatted_values[name] = Tuple(value)
		elif type(value) == bool:
			formatted_values[name] = str(value).lower()
		else:
			formatted_values[name] = value

	try:
		formatted_command = command.format(**formatted_values)
	except KeyError as e:
		raise FatalError('invalid placeholder %s in format: %s' % (str(e).lower(), command), ERROR_INVALID_PLACEHOLDER)
	except Exception as e:
		raise FatalError('%s: %s' % (str(e).lower(), command), ERROR_OTHER_EXCEPTION)

	try:
		if listen_mode:
			try:
				output = subprocess.check_output(formatted_command, stderr=subprocess.STDOUT, shell=True)
			except subprocess.CalledProcessError as e:
				output = e.output

			ctx.output(output)
		else:
			subprocess.call(formatted_command, shell=True)
	except Exception as e:
		raise FatalError('%s: %s' % (str(e).lower(), formatted_command), ERROR_OTHER_EXCEPTION)

def output_response(ctx, names, values):
	lines = []

	for name, value in zip(names, values):
		if type(value) == tuple:
			lines.append('{0}={1}'.format(name, ctx.item_separator.join(map(str, value))))
		elif type(value) == bool:
			lines.append('{0}={1}'.format(name, str(value).lower()))
		else:
			lines.append('{0}={1}'.format(name, value))

	ctx.output(line_separator.join(lines) + group_terminator)

def common_get_identity(ctx, prog_prefix, klass, argv):
	parser = ParserWithExecute(ctx, prog_prefix + ' get-identity')

	args = parser.parse_args(argv)

	device_send_request(ctx, klass, 255, (), '', '8s 8s c 3B 3B H', args.execute, False,
	                    ['uid', 'connected-uid', 'position', 'hardware-version', 'firmware-version', 'device-identifier'],
	                    [None, None, None, None, None, device_identifier_symbols])



# -*- coding: utf-8 -*-
# Copyright (C) 2012-2014 Matthias Bolte <matthias@tinkerforge.com>
# Copyright (C) 2011-2012 Olaf LÃ¼ke <olaf@tinkerforge.com>
#
# Redistribution and use in source and binary forms of this file,
# with or without modification, are permitted. See the Creative
# Commons Zero (CC0 1.0) License for more details.

from threading import Thread, Lock, Semaphore

# current_thread for python 2.6, currentThread for python 2.5
try:
    from threading import current_thread
except ImportError:
    from threading import currentThread as current_thread

# Queue for python 2, queue for python 3
try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty

import struct
import socket
import types
import sys
import time
import os
import math
import hmac
import hashlib
import errno

# use normal tuples instead of namedtuples in python version below 2.6
if sys.hexversion < 0x02060000:
    def namedtuple(typename, field_names, verbose=False, rename=False):
        def ntuple(*args):
            return args

        return ntuple
else:
    from collections import namedtuple

def get_uid_from_data(data):
    return struct.unpack('<I', data[0:4])[0]

def get_length_from_data(data):
    return struct.unpack('<B', data[4:5])[0]

def get_function_id_from_data(data):
    return struct.unpack('<B', data[5:6])[0]

def get_sequence_number_from_data(data):
    return (struct.unpack('<B', data[6:7])[0] >> 4) & 0x0F

def get_error_code_from_data(data):
    return (struct.unpack('<B', data[7:8])[0] >> 6) & 0x03

BASE58 = '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
def base58encode(value):
    encoded = ''
    while value >= 58:
        div, mod = divmod(value, 58)
        encoded = BASE58[mod] + encoded
        value = div
    encoded = BASE58[value] + encoded
    return encoded

def base58decode(encoded):
    value = 0
    column_multiplier = 1
    for c in encoded[::-1]:
        column = BASE58.index(c)
        value += column * column_multiplier
        column_multiplier *= 58
    return value

def uid64_to_uid32(uid64):
    value1 = uid64 & 0xFFFFFFFF
    value2 = (uid64 >> 32) & 0xFFFFFFFF

    uid32  = (value1 & 0x00000FFF)
    uid32 |= (value1 & 0x0F000000) >> 12
    uid32 |= (value2 & 0x0000003F) << 16
    uid32 |= (value2 & 0x000F0000) << 6
    uid32 |= (value2 & 0x3F000000) << 2

    return uid32

class Error(Exception):
    TIMEOUT = -1
    NOT_ADDED = -6 # obsolete since v2.0
    ALREADY_CONNECTED = -7
    NOT_CONNECTED = -8
    INVALID_PARAMETER = -9
    NOT_SUPPORTED = -10
    UNKNOWN_ERROR_CODE = -11

    def __init__(self, value, description):
        self.value = value
        self.description = description

    def __str__(self):
        return str(self.value) + ': ' + str(self.description)

class Device:
    RESPONSE_EXPECTED_INVALID_FUNCTION_ID = 0
    RESPONSE_EXPECTED_ALWAYS_TRUE = 1 # getter
    RESPONSE_EXPECTED_ALWAYS_FALSE = 2 # callback
    RESPONSE_EXPECTED_TRUE = 3 # setter
    RESPONSE_EXPECTED_FALSE = 4 # setter, default

    def __init__(self, uid, ipcon):
        """
        Creates the device object with the unique device ID *uid* and adds
        it to the IPConnection *ipcon*.
        """

        uid_ = base58decode(uid)

        if uid_ > 0xFFFFFFFF:
            uid_ = uid64_to_uid32(uid_)

        self.uid = uid_
        self.ipcon = ipcon
        self.api_version = (0, 0, 0)
        self.registered_callbacks = {}
        self.callback_formats = {}
        self.expected_response_function_id = None # protected by request_lock
        self.expected_response_sequence_number = None # protected by request_lock
        self.response_queue = Queue()
        self.request_lock = Lock()

        self.response_expected = [Device.RESPONSE_EXPECTED_INVALID_FUNCTION_ID] * 256
        self.response_expected[IPConnection.FUNCTION_ENUMERATE] = Device.RESPONSE_EXPECTED_ALWAYS_FALSE
        self.response_expected[IPConnection.FUNCTION_ADC_CALIBRATE] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_GET_ADC_CALIBRATION] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_READ_BRICKLET_UID] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_WRITE_BRICKLET_UID] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_READ_BRICKLET_PLUGIN] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_WRITE_BRICKLET_PLUGIN] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.CALLBACK_ENUMERATE] = Device.RESPONSE_EXPECTED_ALWAYS_FALSE

        ipcon.devices[self.uid] = self # FIXME: maybe use a weakref here

    def get_api_version(self):
        """
        Returns the API version (major, minor, revision) of the bindings for
        this device.
        """

        return self.api_version

    def get_response_expected(self, function_id):
        """
        Returns the response expected flag for the function specified by the
        *function_id* parameter. It is *true* if the function is expected to
        send a response, *false* otherwise.

        For getter functions this is enabled by default and cannot be disabled,
        because those functions will always send a response. For callback
        configuration functions it is enabled by default too, but can be
        disabled via the set_response_expected function. For setter functions
        it is disabled by default and can be enabled.

        Enabling the response expected flag for a setter function allows to
        detect timeouts and other error conditions calls of this setter as
        well. The device will then send a response for this purpose. If this
        flag is disabled for a setter function then no response is send and
        errors are silently ignored, because they cannot be detected.
        """

        if function_id < 0 or function_id >= len(self.response_expected):
            raise ValueError('Function ID {0} out of range'.format(function_id))

        flag = self.response_expected[function_id]

        if flag == Device.RESPONSE_EXPECTED_INVALID_FUNCTION_ID:
            raise ValueError('Invalid function ID {0}'.format(function_id))

        return flag in [Device.RESPONSE_EXPECTED_ALWAYS_TRUE, Device.RESPONSE_EXPECTED_TRUE]

    def set_response_expected(self, function_id, response_expected):
        """
        Changes the response expected flag of the function specified by the
        *function_id* parameter. This flag can only be changed for setter
        (default value: *false*) and callback configuration functions
        (default value: *true*). For getter functions it is always enabled
        and callbacks it is always disabled.

        Enabling the response expected flag for a setter function allows to
        detect timeouts and other error conditions calls of this setter as
        well. The device will then send a response for this purpose. If this
        flag is disabled for a setter function then no response is send and
        errors are silently ignored, because they cannot be detected.
        """

        if function_id < 0 or function_id >= len(self.response_expected):
            raise ValueError('Function ID {0} out of range'.format(function_id))

        flag = self.response_expected[function_id]

        if flag == Device.RESPONSE_EXPECTED_INVALID_FUNCTION_ID:
            raise ValueError('Invalid function ID {0}'.format(function_id))

        if flag in [Device.RESPONSE_EXPECTED_ALWAYS_TRUE, Device.RESPONSE_EXPECTED_ALWAYS_FALSE]:
            raise ValueError('Response Expected flag cannot be changed for function ID {0}'.format(function_id))

        if bool(response_expected):
            self.response_expected[function_id] = Device.RESPONSE_EXPECTED_TRUE
        else:
            self.response_expected[function_id] = Device.RESPONSE_EXPECTED_FALSE

    def set_response_expected_all(self, response_expected):
        """
        Changes the response expected flag for all setter and callback
        configuration functions of this device at once.
        """

        if bool(response_expected):
            flag = Device.RESPONSE_EXPECTED_TRUE
        else:
            flag = Device.RESPONSE_EXPECTED_FALSE

        for i in range(len(self.response_expected)):
            if self.response_expected[i] in [Device.RESPONSE_EXPECTED_TRUE, Device.RESPONSE_EXPECTED_FALSE]:
                self.response_expected[i] = flag

class BrickDaemon(Device):
    FUNCTION_GET_AUTHENTICATION_NONCE = 1
    FUNCTION_AUTHENTICATE = 2

    def __init__(self, uid, ipcon):
        Device.__init__(self, uid, ipcon)

        self.api_version = (2, 0, 0)

        self.response_expected[BrickDaemon.FUNCTION_GET_AUTHENTICATION_NONCE] = BrickDaemon.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[BrickDaemon.FUNCTION_AUTHENTICATE] = BrickDaemon.RESPONSE_EXPECTED_TRUE

    def get_authentication_nonce(self):
        return self.ipcon.send_request(self, BrickDaemon.FUNCTION_GET_AUTHENTICATION_NONCE, (), '', '4B')

    def authenticate(self, client_nonce, digest):
        self.ipcon.send_request(self, BrickDaemon.FUNCTION_AUTHENTICATE, (client_nonce, digest), '4B 20B', '')

class IPConnection:
    FUNCTION_ENUMERATE = 254
    FUNCTION_ADC_CALIBRATE = 251
    FUNCTION_GET_ADC_CALIBRATION = 250
    FUNCTION_READ_BRICKLET_UID = 249
    FUNCTION_WRITE_BRICKLET_UID = 248
    FUNCTION_READ_BRICKLET_PLUGIN = 247
    FUNCTION_WRITE_BRICKLET_PLUGIN = 246
    FUNCTION_DISCONNECT_PROBE = 128

    CALLBACK_ENUMERATE = 253
    CALLBACK_CONNECTED = 0
    CALLBACK_DISCONNECTED = 1

    BROADCAST_UID = 0

    PLUGIN_CHUNK_SIZE = 32

    # enumeration_type parameter to the enumerate callback
    ENUMERATION_TYPE_AVAILABLE = 0
    ENUMERATION_TYPE_CONNECTED = 1
    ENUMERATION_TYPE_DISCONNECTED = 2

    # connect_reason parameter to the connected callback
    CONNECT_REASON_REQUEST = 0
    CONNECT_REASON_AUTO_RECONNECT = 1

    # disconnect_reason parameter to the disconnected callback
    DISCONNECT_REASON_REQUEST = 0
    DISCONNECT_REASON_ERROR = 1
    DISCONNECT_REASON_SHUTDOWN = 2

    # returned by get_connection_state
    CONNECTION_STATE_DISCONNECTED = 0
    CONNECTION_STATE_CONNECTED = 1
    CONNECTION_STATE_PENDING = 2 # auto-reconnect in process

    QUEUE_EXIT = 0
    QUEUE_META = 1
    QUEUE_PACKET = 2

    DISCONNECT_PROBE_INTERVAL = 5

    class CallbackContext:
        def __init__(self):
            self.queue = None
            self.thread = None
            self.packet_dispatch_allowed = False
            self.lock = None

    def __init__(self):
        """
        Creates an IP Connection object that can be used to enumerate the available
        devices. It is also required for the constructor of Bricks and Bricklets.
        """

        self.host = None
        self.port = None
        self.timeout = 2.5
        self.auto_reconnect = True
        self.auto_reconnect_allowed = False
        self.auto_reconnect_pending = False
        self.sequence_number_lock = Lock()
        self.next_sequence_number = 0 # protected by sequence_number_lock
        self.authentication_lock = Lock() # protects authentication handshake
        self.next_authentication_nonce = 0 # protected by authentication_lock
        self.devices = {}
        self.registered_callbacks = {}
        self.socket = None # protected by socket_lock
        self.socket_id = 0 # protected by socket_lock
        self.socket_lock = Lock()
        self.socket_send_lock = Lock()
        self.receive_flag = False
        self.receive_thread = None
        self.callback = None
        self.disconnect_probe_flag = False
        self.disconnect_probe_queue = None
        self.disconnect_probe_thread = None
        self.waiter = Semaphore()
        self.brickd = BrickDaemon("2", self)

    def connect(self, host, port):
        """
        Creates a TCP/IP connection to the given *host* and *port*. The host
        and port can point to a Brick Daemon or to a WIFI/Ethernet Extension.

        Devices can only be controlled when the connection was established
        successfully.

        Blocks until the connection is established and throws an exception if
        there is no Brick Daemon or WIFI/Ethernet Extension listening at the
        given host and port.
        """

        with self.socket_lock:
            if self.socket is not None:
                raise Error(Error.ALREADY_CONNECTED,
                            'Already connected to {0}:{1}'.format(self.host, self.port))

            self.host = host
            self.port = port

            self.connect_unlocked(False)

    def disconnect(self):
        """
        Disconnects the TCP/IP connection from the Brick Daemon or the
        WIFI/Ethernet Extension.
        """

        with self.socket_lock:
            self.auto_reconnect_allowed = False

            if self.auto_reconnect_pending:
                # abort potentially pending auto reconnect
                self.auto_reconnect_pending = False
            else:
                if self.socket is None:
                    raise Error(Error.NOT_CONNECTED, 'Not connected')

                self.disconnect_unlocked()

            # end callback thread
            callback = self.callback
            self.callback = None

        # do this outside of socket_lock to allow calling (dis-)connect from
        # the callbacks while blocking on the join call here
        callback.queue.put((IPConnection.QUEUE_META,
                            (IPConnection.CALLBACK_DISCONNECTED,
                             IPConnection.DISCONNECT_REASON_REQUEST, None)))
        callback.queue.put((IPConnection.QUEUE_EXIT, None))

        if current_thread() is not callback.thread:
            callback.thread.join()

    def authenticate(self, secret):
        """
        Performs an authentication handshake with the connected Brick Daemon or
        WIFI/Ethernet Extension. If the handshake succeeds the connection switches
        from non-authenticated to authenticated state and communication can
        continue as normal. If the handshake fails then the connection gets closed.
        Authentication can fail if the wrong secret was used or if authentication
        is not enabled at all on the Brick Daemon or the WIFI/Ethernet Extension.

        For more information about authentication see
        http://www.tinkerforge.com/en/doc/Tutorials/Tutorial_Authentication/Tutorial.html
        """

        secret_bytes = secret.encode('ascii')

        with self.authentication_lock:
            if self.next_authentication_nonce == 0:
                try:
                    self.next_authentication_nonce = struct.unpack('<I', os.urandom(4))[0]
                except NotImplementedError:
                    subseconds, seconds = math.modf(time.time())
                    seconds = int(seconds)
                    subseconds = int(subseconds * 1000000)
                    self.next_authentication_nonce = ((seconds << 26 | seconds >> 6) & 0xFFFFFFFF) + subseconds + os.getpid()

            server_nonce = self.brickd.get_authentication_nonce()
            client_nonce = struct.unpack('<4B', struct.pack('<I', self.next_authentication_nonce))
            self.next_authentication_nonce = (self.next_authentication_nonce + 1) % (1 << 32)

            h = hmac.new(secret_bytes, digestmod=hashlib.sha1)

            h.update(struct.pack('<4B', *server_nonce))
            h.update(struct.pack('<4B', *client_nonce))

            digest = struct.unpack('<20B', h.digest())
            h = None

            self.brickd.authenticate(client_nonce, digest)

    def get_connection_state(self):
        """
        Can return the following states:

        - CONNECTION_STATE_DISCONNECTED: No connection is established.
        - CONNECTION_STATE_CONNECTED: A connection to the Brick Daemon or
          the WIFI/Ethernet Extension is established.
        - CONNECTION_STATE_PENDING: IP Connection is currently trying to
          connect.
        """

        if self.socket is not None:
            return IPConnection.CONNECTION_STATE_CONNECTED
        elif self.auto_reconnect_pending:
            return IPConnection.CONNECTION_STATE_PENDING
        else:
            return IPConnection.CONNECTION_STATE_DISCONNECTED

    def set_auto_reconnect(self, auto_reconnect):
        """
        Enables or disables auto-reconnect. If auto-reconnect is enabled,
        the IP Connection will try to reconnect to the previously given
        host and port, if the connection is lost.

        Default value is *True*.
        """

        self.auto_reconnect = bool(auto_reconnect)

        if not self.auto_reconnect:
            # abort potentially pending auto reconnect
            self.auto_reconnect_allowed = False

    def get_auto_reconnect(self):
        """
        Returns *true* if auto-reconnect is enabled, *false* otherwise.
        """

        return self.auto_reconnect

    def set_timeout(self, timeout):
        """
        Sets the timeout in seconds for getters and for setters for which the
        response expected flag is activated.

        Default timeout is 2.5.
        """

        timeout = float(timeout)

        if timeout < 0:
            raise ValueError('Timeout cannot be negative')

        self.timeout = timeout

    def get_timeout(self):
        """
        Returns the timeout as set by set_timeout.
        """

        return self.timeout

    def enumerate(self):
        """
        Broadcasts an enumerate request. All devices will respond with an
        enumerate callback.
        """

        request, _, _ = self.create_packet_header(None, 8, IPConnection.FUNCTION_ENUMERATE)

        self.send(request)

    def wait(self):
        """
        Stops the current thread until unwait is called.

        This is useful if you rely solely on callbacks for events, if you want
        to wait for a specific callback or if the IP Connection was created in
        a thread.

        Wait and unwait act in the same way as "acquire" and "release" of a
        semaphore.
        """
        self.waiter.acquire()

    def unwait(self):
        """
        Unwaits the thread previously stopped by wait.

        Wait and unwait act in the same way as "acquire" and "release" of
        a semaphore.
        """
        self.waiter.release()

    def register_callback(self, id, callback):
        """
        Registers a callback with ID *id* to the function *callback*.
        """

        self.registered_callbacks[id] = callback

    def connect_unlocked(self, is_auto_reconnect):
        # NOTE: assumes that socket_lock is locked

        # create callback thread and queue
        if self.callback is None:
            try:
                self.callback = IPConnection.CallbackContext()
                self.callback.queue = Queue()
                self.callback.packet_dispatch_allowed = False
                self.callback.lock = Lock()
                self.callback.thread = Thread(name='Callback-Processor',
                                              target=self.callback_loop,
                                              args=(self.callback, ))
                self.callback.thread.daemon = True
                self.callback.thread.start()
            except:
                self.callback = None
                raise

        # create and connect socket
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            self.socket.connect((self.host, self.port))
            self.socket_id += 1
        except:
            def cleanup():
                self.socket = None

                # end callback thread
                if not is_auto_reconnect:
                    self.callback.queue.put((IPConnection.QUEUE_EXIT, None))

                    if current_thread() is not self.callback.thread:
                        self.callback.thread.join()

                    self.callback = None

            cleanup()
            raise

        # create disconnect probe thread
        try:
            self.disconnect_probe_flag = True
            self.disconnect_probe_queue = Queue()
            self.disconnect_probe_thread = Thread(name='Disconnect-Prober',
                                                  target=self.disconnect_probe_loop,
                                                  args=(self.disconnect_probe_queue, ))
            self.disconnect_probe_thread.daemon = True
            self.disconnect_probe_thread.start()
        except:
            def cleanup():
                self.disconnect_probe_thread = None

                # close socket
                self.socket.close()
                self.socket = None

                # end callback thread
                if not is_auto_reconnect:
                    self.callback.queue.put((IPConnection.QUEUE_EXIT, None))

                    if current_thread() is not self.callback.thread:
                        self.callback.thread.join()

                    self.callback = None

            cleanup()
            raise

        # create receive thread
        self.callback.packet_dispatch_allowed = True

        try:
            self.receive_flag = True
            self.receive_thread = Thread(name='Brickd-Receiver',
                                         target=self.receive_loop,
                                         args=(self.socket_id, ))
            self.receive_thread.daemon = True
            self.receive_thread.start()
        except:
            def cleanup():
                # close socket
                self.disconnect_unlocked()

                # end callback thread
                if not is_auto_reconnect:
                    self.callback.queue.put((IPConnection.QUEUE_EXIT, None))

                    if current_thread() is not self.callback.thread:
                        self.callback.thread.join()

                    self.callback = None

            cleanup()
            raise

        self.auto_reconnect_allowed = False
        self.auto_reconnect_pending = False

        if is_auto_reconnect:
            connect_reason = IPConnection.CONNECT_REASON_AUTO_RECONNECT
        else:
            connect_reason = IPConnection.CONNECT_REASON_REQUEST

        self.callback.queue.put((IPConnection.QUEUE_META,
                                (IPConnection.CALLBACK_CONNECTED,
                                 connect_reason, None)))

    def disconnect_unlocked(self):
        # NOTE: assumes that socket_lock is locked

        # end disconnect probe thread
        self.disconnect_probe_queue.put(True)
        self.disconnect_probe_thread.join() # FIXME: use a timeout?
        self.disconnect_probe_thread = None

        # stop dispatching packet callbacks before ending the receive
        # thread to avoid timeout exceptions due to callback functions
        # trying to call getters
        if current_thread() is not self.callback.thread:
            # FIXME: cannot hold callback lock here because this can
            #        deadlock due to an ordering problem with the socket lock
            #with self.callback.lock:
            if True:
                self.callback.packet_dispatch_allowed = False
        else:
            self.callback.packet_dispatch_allowed = False

        # end receive thread
        self.receive_flag = False

        try:
            self.socket.shutdown(socket.SHUT_RDWR)
        except socket.error:
            pass

        if self.receive_thread is not None:
            self.receive_thread.join() # FIXME: use a timeout?
            self.receive_thread = None

        # close socket
        self.socket.close()
        self.socket = None

    def receive_loop(self, socket_id):
        if sys.hexversion < 0x03000000:
            pending_data = ''
        else:
            pending_data = bytes()

        while self.receive_flag:
            try:
                data = self.socket.recv(8192)
            except socket.error:
                if self.receive_flag:
                    e = sys.exc_info()[1]
                    if e.errno == errno.EINTR:
                        continue

                    self.handle_disconnect_by_peer(IPConnection.DISCONNECT_REASON_ERROR, socket_id, False)
                break

            if len(data) == 0:
                if self.receive_flag:
                    self.handle_disconnect_by_peer(IPConnection.DISCONNECT_REASON_SHUTDOWN, socket_id, False)
                break

            pending_data += data

            while self.receive_flag:
                if len(pending_data) < 8:
                    # Wait for complete header
                    break

                length = get_length_from_data(pending_data)

                if len(pending_data) < length:
                    # Wait for complete packet
                    break

                packet = pending_data[0:length]
                pending_data = pending_data[length:]

                self.handle_response(packet)

    def dispatch_meta(self, function_id, parameter, socket_id):
        if function_id == IPConnection.CALLBACK_CONNECTED:
            if IPConnection.CALLBACK_CONNECTED in self.registered_callbacks and \
               self.registered_callbacks[IPConnection.CALLBACK_CONNECTED] is not None:
                self.registered_callbacks[IPConnection.CALLBACK_CONNECTED](parameter)
        elif function_id == IPConnection.CALLBACK_DISCONNECTED:
            if parameter != IPConnection.DISCONNECT_REASON_REQUEST:
                # need to do this here, the receive_loop is not allowed to
                # hold the socket_lock because this could cause a deadlock
                # with a concurrent call to the (dis-)connect function
                with self.socket_lock:
                    # don't close the socket if it got disconnected or
                    # reconnected in the meantime
                    if self.socket is not None and self.socket_id == socket_id:
                        # end disconnect probe thread
                        self.disconnect_probe_queue.put(True)
                        self.disconnect_probe_thread.join() # FIXME: use a timeout?
                        self.disconnect_probe_thread = None

                        # close socket
                        self.socket.close()
                        self.socket = None

            # FIXME: wait a moment here, otherwise the next connect
            # attempt will succeed, even if there is no open server
            # socket. the first receive will then fail directly
            time.sleep(0.1)

            if IPConnection.CALLBACK_DISCONNECTED in self.registered_callbacks and \
               self.registered_callbacks[IPConnection.CALLBACK_DISCONNECTED] is not None:
                self.registered_callbacks[IPConnection.CALLBACK_DISCONNECTED](parameter)

            if parameter != IPConnection.DISCONNECT_REASON_REQUEST and \
               self.auto_reconnect and self.auto_reconnect_allowed:
                self.auto_reconnect_pending = True
                retry = True

                # block here until reconnect. this is okay, there is no
                # callback to deliver when there is no connection
                while retry:
                    retry = False

                    with self.socket_lock:
                        if self.auto_reconnect_allowed and self.socket is None:
                            try:
                                self.connect_unlocked(True)
                            except:
                                retry = True
                        else:
                            self.auto_reconnect_pending = False

                    if retry:
                        time.sleep(0.1)

    def dispatch_packet(self, packet):
        uid = get_uid_from_data(packet)
        length = get_length_from_data(packet)
        function_id = get_function_id_from_data(packet)
        payload = packet[8:]

        if function_id == IPConnection.CALLBACK_ENUMERATE and \
           IPConnection.CALLBACK_ENUMERATE in self.registered_callbacks:
            uid, connected_uid, position, hardware_version, \
                firmware_version, device_identifier, enumeration_type = \
                self.deserialize_data(payload, '8s 8s c 3B 3B H B')

            cb = self.registered_callbacks[IPConnection.CALLBACK_ENUMERATE]
            cb(uid, connected_uid, position, hardware_version,
               firmware_version, device_identifier, enumeration_type)
            return

        if uid not in self.devices:
            return

        device = self.devices[uid]

        if function_id in device.registered_callbacks and \
           device.registered_callbacks[function_id] is not None:
            cb = device.registered_callbacks[function_id]
            form = device.callback_formats[function_id]

            if len(form) == 0:
                cb()
            elif len(form) == 1:
                cb(self.deserialize_data(payload, form))
            else:
                cb(*self.deserialize_data(payload, form))

    def callback_loop(self, callback):
        while True:
            kind, data = callback.queue.get()

            # FIXME: cannot hold callback lock here because this can
            #        deadlock due to an ordering problem with the socket lock
            #with callback.lock:
            if True:
                if kind == IPConnection.QUEUE_EXIT:
                    break
                elif kind == IPConnection.QUEUE_META:
                    self.dispatch_meta(*data)
                elif kind == IPConnection.QUEUE_PACKET:
                    # don't dispatch callbacks when the receive thread isn't running
                    if callback.packet_dispatch_allowed:
                        self.dispatch_packet(data)

    # NOTE: the disconnect probe thread is not allowed to hold the socket_lock at any
    #       time because it is created and joined while the socket_lock is locked
    def disconnect_probe_loop(self, disconnect_probe_queue):
        request, _, _ = self.create_packet_header(None, 8, IPConnection.FUNCTION_DISCONNECT_PROBE)

        while True:
            try:
                disconnect_probe_queue.get(True, IPConnection.DISCONNECT_PROBE_INTERVAL)
                break
            except Empty:
                pass

            if self.disconnect_probe_flag:
                try:
                    with self.socket_send_lock:
                        self.socket.send(request)
                except socket.error:
                    self.handle_disconnect_by_peer(IPConnection.DISCONNECT_REASON_ERROR,
                                                   self.socket_id, False)
                    break
            else:
                self.disconnect_probe_flag = True

    def deserialize_data(self, data, form):
        ret = []
        for f in form.split(' '):
            f = '<' + f
            length = struct.calcsize(f)

            x = struct.unpack(f, data[:length])
            if len(x) > 1:
                if 'c' in f:
                    x = tuple([self.handle_deserialized_char(c) for c in x])
                ret.append(x)
            elif 'c' in f:
                ret.append(self.handle_deserialized_char(x[0]))
            elif 's' in f:
                ret.append(self.handle_deserialized_string(x[0]))
            else:
                ret.append(x[0])

            data = data[length:]

        if len(ret) == 1:
            return ret[0]
        else:
            return ret

    def handle_deserialized_char(self, c):
        if sys.hexversion >= 0x03000000:
            c = c.decode('ascii')

        return c

    def handle_deserialized_string(self, s):
        if sys.hexversion >= 0x03000000:
            s = s.decode('ascii')

        i = s.find(chr(0))
        if i >= 0:
            s = s[:i]

        return s

    def send(self, packet):
        with self.socket_lock:
            if self.socket is None:
                raise Error(Error.NOT_CONNECTED, 'Not connected')

            try:
                with self.socket_send_lock:
                    self.socket.send(packet)
            except socket.error:
                self.handle_disconnect_by_peer(IPConnection.DISCONNECT_REASON_ERROR, None, True)
                raise Error(Error.NOT_CONNECTED, 'Not connected')

            self.disconnect_probe_flag = False

    def send_request(self, device, function_id, data, form, form_ret):
        length = 8 + struct.calcsize('<' + form)
        request, response_expected, sequence_number = \
            self.create_packet_header(device, length, function_id)

        def pack_string(f, d):
            if sys.hexversion < 0x03000000:
                if type(d) == types.UnicodeType:
                    f = f.replace('s', 'B')
                    l = map(ord, d)
                    l += [0] * (int(f.replace('B', '')) - len(l))
                    return struct.pack('<' + f, *l)

                else:
                    return struct.pack('<' + f, d)
            else:
                if isinstance(d, str):
                    return struct.pack('<' + f, bytes(map(ord, d)))
                else:
                    return struct.pack('<' + f, d)

        for f, d in zip(form.split(' '), data):
            if len(f) > 1 and not 's' in f and not 'c' in f:
                request += struct.pack('<' + f, *d)
            elif 's' in f:
                request += pack_string(f, d)
            elif 'c' in f:
                if len(f) > 1:
                    if int(f.replace('c', '')) != len(d):
                        raise ValueError('Incorrect char list length');
                    for k in d:
                        request += pack_string('c', k)
                else:
                    request += pack_string(f, d)
            else:
                request += struct.pack('<' + f, d)

        if response_expected:
            with device.request_lock:
                device.expected_response_function_id = function_id
                device.expected_response_sequence_number = sequence_number

                try:
                    self.send(request)

                    while True:
                        response = device.response_queue.get(True, self.timeout)

                        if function_id == get_function_id_from_data(response) and \
                           sequence_number == get_sequence_number_from_data(response):
                            # ignore old responses that arrived after the timeout expired, but before setting
                            # expected_response_function_id and expected_response_sequence_number back to None
                            break
                except Empty:
                    msg = 'Did not receive response for function {0} in time'.format(function_id)
                    raise Error(Error.TIMEOUT, msg)
                finally:
                    device.expected_response_function_id = None
                    device.expected_response_sequence_number = None

            error_code = get_error_code_from_data(response)

            if error_code == 0:
                # no error
                pass
            elif error_code == 1:
                msg = 'Got invalid parameter for function {0}'.format(function_id)
                raise Error(Error.INVALID_PARAMETER, msg)
            elif error_code == 2:
                msg = 'Function {0} is not supported'.format(function_id)
                raise Error(Error.NOT_SUPPORTED, msg)
            else:
                msg = 'Function {0} returned an unknown error'.format(function_id)
                raise Error(Error.UNKNOWN_ERROR_CODE, msg)

            if len(form_ret) > 0:
                return self.deserialize_data(response[8:], form_ret)
        else:
            self.send(request)

    def get_next_sequence_number(self):
        with self.sequence_number_lock:
            sequence_number = self.next_sequence_number + 1
            self.next_sequence_number = sequence_number % 15
            return sequence_number

    def handle_response(self, packet):
        self.disconnect_probe_flag = False

        function_id = get_function_id_from_data(packet)
        sequence_number = get_sequence_number_from_data(packet)

        if sequence_number == 0 and function_id == IPConnection.CALLBACK_ENUMERATE:
            if IPConnection.CALLBACK_ENUMERATE in self.registered_callbacks:
                self.callback.queue.put((IPConnection.QUEUE_PACKET, packet))
            return

        uid = get_uid_from_data(packet)

        if not uid in self.devices:
            # Response from an unknown device, ignoring it
            return

        device = self.devices[uid]

        if sequence_number == 0:
            if function_id in device.registered_callbacks:
                self.callback.queue.put((IPConnection.QUEUE_PACKET, packet))
            return

        if device.expected_response_function_id == function_id and \
           device.expected_response_sequence_number == sequence_number:
            device.response_queue.put(packet)
            return

        # Response seems to be OK, but can't be handled

    def handle_disconnect_by_peer(self, disconnect_reason, socket_id, disconnect_immediately):
        # NOTE: assumes that socket_lock is locked if disconnect_immediately is true

        self.auto_reconnect_allowed = True

        if disconnect_immediately:
            self.disconnect_unlocked()

        self.callback.queue.put((IPConnection.QUEUE_META,
                                 (IPConnection.CALLBACK_DISCONNECTED,
                                  disconnect_reason, socket_id)))

    def create_packet_header(self, device, length, function_id):
        uid = IPConnection.BROADCAST_UID
        sequence_number = self.get_next_sequence_number()
        r_bit = 0

        if device is not None:
            uid = device.uid

            if device.get_response_expected(function_id):
                r_bit = 1

        sequence_number_and_options = (sequence_number << 4) | (r_bit << 3)

        return (struct.pack('<IBBBB', uid, length, function_id,
                            sequence_number_and_options, 0),
                bool(r_bit),
                sequence_number)

    def write_bricklet_plugin(self, device, port, position, plugin_chunk):
        self.send_request(device,
                          IPConnection.FUNCTION_WRITE_BRICKLET_PLUGIN,
                          (port, position, plugin_chunk),
                          'c B 32B',
                          '')

    def read_bricklet_plugin(self, device, port, position):
        return self.send_request(device,
                                 IPConnection.FUNCTION_READ_BRICKLET_PLUGIN,
                                 (port, position),
                                 'c B',
                                 '32B')

    def get_adc_calibration(self, device):
        return self.send_request(device,
                                 IPConnection.FUNCTION_GET_ADC_CALIBRATION,
                                 (),
                                 '',
                                 'h h')

    def adc_calibrate(self, device, port):
        self.send_request(device,
                          IPConnection.FUNCTION_ADC_CALIBRATE,
                          (port,),
                          'c',
                          '')

    def write_bricklet_uid(self, device, port, uid):
        uid_int = base58decode(uid)

        self.send_request(device,
                          IPConnection.FUNCTION_WRITE_BRICKLET_UID,
                          (port, uid_int),
                          'c I',
                          '')

    def read_bricklet_uid(self, device, port):
        uid_int = self.send_request(device,
                                    IPConnection.FUNCTION_READ_BRICKLET_UID,
                                    (port,),
                                    'c',
                                    'I')

        return base58encode(uid_int)




class AmbientLightBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'

def call_ambient_light_bricklet(ctx, argv):
	prog_prefix = 'call ambient-light-bricklet <uid>'

	def get_illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 1, (), '', 'H', args.execute, False, ['illuminance'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_illuminance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_illuminance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_illuminance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 7, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_illuminance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 8, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, AmbientLightBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AmbientLightBricklet, argv)

	functions = {
	'get-illuminance': get_illuminance,
	'get-analog-value': get_analog_value,
	'set-illuminance-callback-period': set_illuminance_callback_period,
	'get-illuminance-callback-period': get_illuminance_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-illuminance-callback-threshold': set_illuminance_callback_threshold,
	'get-illuminance-callback-threshold': get_illuminance_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'ambient-light-bricklet', functions, argv)

def dispatch_ambient_light_bricklet(ctx, argv):
	prog_prefix = 'dispatch ambient-light-bricklet <uid>'

	def illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance')

		args = parser.parse_args(argv)

		device_callback(ctx, AmbientLightBricklet, 13, args.execute, ['illuminance'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, AmbientLightBricklet, 14, args.execute, ['value'])

	def illuminance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, AmbientLightBricklet, 15, args.execute, ['illuminance'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, AmbientLightBricklet, 16, args.execute, ['value'])

	callbacks = {
	'illuminance': illuminance,
	'analog-value': analog_value,
	'illuminance-reached': illuminance_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'ambient-light-bricklet', callbacks, argv)

class AnalogInBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[17] = 4; re[18] = 1; re[19] = 4; re[20] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'

def call_analog_in_bricklet(ctx, argv):
	prog_prefix = 'call analog-in-bricklet <uid>'

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 1, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 7, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 8, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_range(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-range')

		parser.add_argument('range', type=create_symbol_converter(ctx, convert_int, {'up-to-6v': 1, 'up-to-36v': 3, 'up-to-3v': 5, 'up-to-45v': 4, 'up-to-10v': 2, 'automatic': 0}), help='int (automatic: 0, up-to-6v: 1, up-to-10v: 2, up-to-36v: 3, up-to-45v: 4, up-to-3v: 5)', metavar='<range>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 17, (args.range,), 'B', '', None, args.expect_response, [], [])

	def get_range(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-range')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 18, (), '', 'B', args.execute, False, ['range'], [{0: 'automatic', 1: 'up-to-6v', 2: 'up-to-10v', 3: 'up-to-36v', 4: 'up-to-45v', 5: 'up-to-3v'}])

	def set_averaging(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-averaging')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 19, (args.average,), 'B', '', None, args.expect_response, [], [])

	def get_averaging(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-averaging')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogInBricklet, 20, (), '', 'B', args.execute, False, ['average'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AnalogInBricklet, argv)

	functions = {
	'get-voltage': get_voltage,
	'get-analog-value': get_analog_value,
	'set-voltage-callback-period': set_voltage_callback_period,
	'get-voltage-callback-period': get_voltage_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-voltage-callback-threshold': set_voltage_callback_threshold,
	'get-voltage-callback-threshold': get_voltage_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-range': set_range,
	'get-range': get_range,
	'set-averaging': set_averaging,
	'get-averaging': get_averaging,
	'get-identity': get_identity
	}

	call_generic(ctx, 'analog-in-bricklet', functions, argv)

def dispatch_analog_in_bricklet(ctx, argv):
	prog_prefix = 'dispatch analog-in-bricklet <uid>'

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_callback(ctx, AnalogInBricklet, 13, args.execute, ['voltage'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, AnalogInBricklet, 14, args.execute, ['value'])

	def voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, AnalogInBricklet, 15, args.execute, ['voltage'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, AnalogInBricklet, 16, args.execute, ['value'])

	callbacks = {
	'voltage': voltage,
	'analog-value': analog_value,
	'voltage-reached': voltage_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'analog-in-bricklet', callbacks, argv)

class AnalogOutBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 4; re[4] = 1; re[255] = 1


def call_analog_out_bricklet(ctx, argv):
	prog_prefix = 'call analog-out-bricklet <uid>'

	def set_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogOutBricklet, 1, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogOutBricklet, 2, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'analog-value': 0, '500k-to-ground': 3, '100k-to-ground': 2, '1k-to-ground': 1}), help='int (analog-value: 0, 1k-to-ground: 1, 100k-to-ground: 2, 500k-to-ground: 3)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogOutBricklet, 3, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-mode')

		args = parser.parse_args(argv)

		device_send_request(ctx, AnalogOutBricklet, 4, (), '', 'B', args.execute, False, ['mode'], [{0: 'analog-value', 1: '1k-to-ground', 2: '100k-to-ground', 3: '500k-to-ground'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AnalogOutBricklet, argv)

	functions = {
	'set-voltage': set_voltage,
	'get-voltage': get_voltage,
	'set-mode': set_mode,
	'get-mode': get_mode,
	'get-identity': get_identity
	}

	call_generic(ctx, 'analog-out-bricklet', functions, argv)

def dispatch_analog_out_bricklet(ctx, argv):
	prog_prefix = 'dispatch analog-out-bricklet <uid>'


	callbacks = {
	
	}

	dispatch_generic(ctx, 'analog-out-bricklet', callbacks, argv)

class BarometerBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 4; re[14] = 1; re[19] = 1; re[20] = 4; re[21] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'i'; cf[16] = 'i'; cf[17] = 'i'; cf[18] = 'i'

def call_barometer_bricklet(ctx, argv):
	prog_prefix = 'call barometer-bricklet <uid>'

	def get_air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 1, (), '', 'i', args.execute, False, ['air-pressure'], [None])

	def get_altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 2, (), '', 'i', args.execute, False, ['altitude'], [None])

	def set_air_pressure_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-air-pressure-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_air_pressure_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_altitude_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-altitude-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_altitude_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_air_pressure_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-air-pressure-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 7, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_air_pressure_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 8, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_altitude_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-altitude-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 9, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_altitude_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 10, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_reference_air_pressure(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-reference-air-pressure')

		parser.add_argument('air_pressure', type=convert_int, help='int', metavar='<air-pressure>')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 13, (args.air_pressure,), 'i', '', None, args.expect_response, [], [])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 14, (), '', 'h', args.execute, False, ['temperature'], [None])

	def get_reference_air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-reference-air-pressure')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 19, (), '', 'i', args.execute, False, ['air-pressure'], [None])

	def set_averaging(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-averaging')

		parser.add_argument('moving_average_pressure', type=convert_int, help='int', metavar='<moving-average-pressure>')
		parser.add_argument('average_pressure', type=convert_int, help='int', metavar='<average-pressure>')
		parser.add_argument('average_temperature', type=convert_int, help='int', metavar='<average-temperature>')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 20, (args.moving_average_pressure, args.average_pressure, args.average_temperature), 'B B B', '', None, args.expect_response, [], [])

	def get_averaging(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-averaging')

		args = parser.parse_args(argv)

		device_send_request(ctx, BarometerBricklet, 21, (), '', 'B B B', args.execute, False, ['moving-average-pressure', 'average-pressure', 'average-temperature'], [None, None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, BarometerBricklet, argv)

	functions = {
	'get-air-pressure': get_air_pressure,
	'get-altitude': get_altitude,
	'set-air-pressure-callback-period': set_air_pressure_callback_period,
	'get-air-pressure-callback-period': get_air_pressure_callback_period,
	'set-altitude-callback-period': set_altitude_callback_period,
	'get-altitude-callback-period': get_altitude_callback_period,
	'set-air-pressure-callback-threshold': set_air_pressure_callback_threshold,
	'get-air-pressure-callback-threshold': get_air_pressure_callback_threshold,
	'set-altitude-callback-threshold': set_altitude_callback_threshold,
	'get-altitude-callback-threshold': get_altitude_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-reference-air-pressure': set_reference_air_pressure,
	'get-chip-temperature': get_chip_temperature,
	'get-reference-air-pressure': get_reference_air_pressure,
	'set-averaging': set_averaging,
	'get-averaging': get_averaging,
	'get-identity': get_identity
	}

	call_generic(ctx, 'barometer-bricklet', functions, argv)

def dispatch_barometer_bricklet(ctx, argv):
	prog_prefix = 'dispatch barometer-bricklet <uid>'

	def air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' air-pressure')

		args = parser.parse_args(argv)

		device_callback(ctx, BarometerBricklet, 15, args.execute, ['air-pressure'])

	def altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' altitude')

		args = parser.parse_args(argv)

		device_callback(ctx, BarometerBricklet, 16, args.execute, ['altitude'])

	def air_pressure_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' air-pressure-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, BarometerBricklet, 17, args.execute, ['air-pressure'])

	def altitude_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' altitude-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, BarometerBricklet, 18, args.execute, ['altitude'])

	callbacks = {
	'air-pressure': air_pressure,
	'altitude': altitude,
	'air-pressure-reached': air_pressure_reached,
	'altitude-reached': altitude_reached
	}

	dispatch_generic(ctx, 'barometer-bricklet', callbacks, argv)

class ColorBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[10] = 4; re[11] = 4; re[12] = 1; re[13] = 4; re[14] = 1; re[15] = 1; re[16] = 1; re[17] = 3; re[18] = 1; re[19] = 3; re[20] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H H H H'; cf[9] = 'H H H H'; cf[21] = 'I'; cf[22] = 'H'

def call_color_bricklet(ctx, argv):
	prog_prefix = 'call color-bricklet <uid>'

	def get_color(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 1, (), '', 'H H H H', args.execute, False, ['r', 'g', 'b', 'c'], [None, None, None, None])

	def set_color_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_color_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_color_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min_r', type=convert_int, help='int', metavar='<min-r>')
		parser.add_argument('max_r', type=convert_int, help='int', metavar='<max-r>')
		parser.add_argument('min_g', type=convert_int, help='int', metavar='<min-g>')
		parser.add_argument('max_g', type=convert_int, help='int', metavar='<max-g>')
		parser.add_argument('min_b', type=convert_int, help='int', metavar='<min-b>')
		parser.add_argument('max_b', type=convert_int, help='int', metavar='<max-b>')
		parser.add_argument('min_c', type=convert_int, help='int', metavar='<min-c>')
		parser.add_argument('max_c', type=convert_int, help='int', metavar='<max-c>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 4, (args.option, args.min_r, args.max_r, args.min_g, args.max_g, args.min_b, args.max_b, args.min_c, args.max_c), 'c H H H H H H H H', '', None, args.expect_response, [], [])

	def get_color_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 5, (), '', 'c H H H H H H H H', args.execute, False, ['option', 'min-r', 'max-r', 'min-g', 'max-g', 'min-b', 'max-b', 'min-c', 'max-c'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None, None, None, None, None, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def light_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' light-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 10, (), '', '', None, args.expect_response, [], [])

	def light_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' light-off')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 11, (), '', '', None, args.expect_response, [], [])

	def is_light_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-light-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 12, (), '', 'B', args.execute, False, ['light'], [{0: 'on', 1: 'off'}])

	def set_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-config')

		parser.add_argument('gain', type=create_symbol_converter(ctx, convert_int, {'1x': 0, '16x': 2, '60x': 3, '4x': 1}), help='int (1x: 0, 4x: 1, 16x: 2, 60x: 3)', metavar='<gain>')
		parser.add_argument('integration_time', type=create_symbol_converter(ctx, convert_int, {'2ms': 0, '154ms': 3, '700ms': 4, '24ms': 1, '101ms': 2}), help='int (2ms: 0, 24ms: 1, 101ms: 2, 154ms: 3, 700ms: 4)', metavar='<integration-time>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 13, (args.gain, args.integration_time), 'B B', '', None, args.expect_response, [], [])

	def get_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-config')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 14, (), '', 'B B', args.execute, False, ['gain', 'integration-time'], [{0: '1x', 1: '4x', 2: '16x', 3: '60x'}, {0: '2ms', 1: '24ms', 2: '101ms', 3: '154ms', 4: '700ms'}])

	def get_illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 15, (), '', 'I', args.execute, False, ['illuminance'], [None])

	def get_color_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 16, (), '', 'H', args.execute, False, ['color-temperature'], [None])

	def set_illuminance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 17, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_illuminance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 18, (), '', 'I', args.execute, False, ['period'], [None])

	def set_color_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 19, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_color_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-temperature-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, ColorBricklet, 20, (), '', 'I', args.execute, False, ['period'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, ColorBricklet, argv)

	functions = {
	'get-color': get_color,
	'set-color-callback-period': set_color_callback_period,
	'get-color-callback-period': get_color_callback_period,
	'set-color-callback-threshold': set_color_callback_threshold,
	'get-color-callback-threshold': get_color_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'light-on': light_on,
	'light-off': light_off,
	'is-light-on': is_light_on,
	'set-config': set_config,
	'get-config': get_config,
	'get-illuminance': get_illuminance,
	'get-color-temperature': get_color_temperature,
	'set-illuminance-callback-period': set_illuminance_callback_period,
	'get-illuminance-callback-period': get_illuminance_callback_period,
	'set-color-temperature-callback-period': set_color_temperature_callback_period,
	'get-color-temperature-callback-period': get_color_temperature_callback_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'color-bricklet', functions, argv)

def dispatch_color_bricklet(ctx, argv):
	prog_prefix = 'dispatch color-bricklet <uid>'

	def color(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' color')

		args = parser.parse_args(argv)

		device_callback(ctx, ColorBricklet, 8, args.execute, ['r', 'g', 'b', 'c'])

	def color_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' color-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, ColorBricklet, 9, args.execute, ['r', 'g', 'b', 'c'])

	def illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance')

		args = parser.parse_args(argv)

		device_callback(ctx, ColorBricklet, 21, args.execute, ['illuminance'])

	def color_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' color-temperature')

		args = parser.parse_args(argv)

		device_callback(ctx, ColorBricklet, 22, args.execute, ['color-temperature'])

	callbacks = {
	'color': color,
	'color-reached': color_reached,
	'illuminance': illuminance,
	'color-temperature': color_temperature
	}

	dispatch_generic(ctx, 'color-bricklet', callbacks, argv)

class Current12Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 4; re[3] = 1; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'h'; cf[16] = 'H'; cf[17] = 'h'; cf[18] = 'H'; cf[19] = ''

def call_current12_bricklet(ctx, argv):
	prog_prefix = 'call current12-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 1, (), '', 'h', args.execute, False, ['current'], [None])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 2, (), '', '', None, args.expect_response, [], [])

	def is_over_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-over-current')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 3, (), '', '?', args.execute, False, ['over'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 4, (), '', 'H', args.execute, False, ['value'], [None])

	def set_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 9, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 10, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 11, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 12, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current12Bricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, Current12Bricklet, argv)

	functions = {
	'get-current': get_current,
	'calibrate': calibrate,
	'is-over-current': is_over_current,
	'get-analog-value': get_analog_value,
	'set-current-callback-period': set_current_callback_period,
	'get-current-callback-period': get_current_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-current-callback-threshold': set_current_callback_threshold,
	'get-current-callback-threshold': get_current_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'current12-bricklet', functions, argv)

def dispatch_current12_bricklet(ctx, argv):
	prog_prefix = 'dispatch current12-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_callback(ctx, Current12Bricklet, 15, args.execute, ['current'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, Current12Bricklet, 16, args.execute, ['value'])

	def current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, Current12Bricklet, 17, args.execute, ['current'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, Current12Bricklet, 18, args.execute, ['value'])

	def over_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' over-current')

		args = parser.parse_args(argv)

		device_callback(ctx, Current12Bricklet, 19, args.execute, [])

	callbacks = {
	'current': current,
	'analog-value': analog_value,
	'current-reached': current_reached,
	'analog-value-reached': analog_value_reached,
	'over-current': over_current
	}

	dispatch_generic(ctx, 'current12-bricklet', callbacks, argv)

class Current25Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 4; re[3] = 1; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'h'; cf[16] = 'H'; cf[17] = 'h'; cf[18] = 'H'; cf[19] = ''

def call_current25_bricklet(ctx, argv):
	prog_prefix = 'call current25-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 1, (), '', 'h', args.execute, False, ['current'], [None])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 2, (), '', '', None, args.expect_response, [], [])

	def is_over_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-over-current')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 3, (), '', '?', args.execute, False, ['over'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 4, (), '', 'H', args.execute, False, ['value'], [None])

	def set_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 9, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 10, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 11, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 12, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, Current25Bricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, Current25Bricklet, argv)

	functions = {
	'get-current': get_current,
	'calibrate': calibrate,
	'is-over-current': is_over_current,
	'get-analog-value': get_analog_value,
	'set-current-callback-period': set_current_callback_period,
	'get-current-callback-period': get_current_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-current-callback-threshold': set_current_callback_threshold,
	'get-current-callback-threshold': get_current_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'current25-bricklet', functions, argv)

def dispatch_current25_bricklet(ctx, argv):
	prog_prefix = 'dispatch current25-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_callback(ctx, Current25Bricklet, 15, args.execute, ['current'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, Current25Bricklet, 16, args.execute, ['value'])

	def current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, Current25Bricklet, 17, args.execute, ['current'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, Current25Bricklet, 18, args.execute, ['value'])

	def over_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' over-current')

		args = parser.parse_args(argv)

		device_callback(ctx, Current25Bricklet, 19, args.execute, [])

	callbacks = {
	'current': current,
	'analog-value': analog_value,
	'current-reached': current_reached,
	'analog-value-reached': analog_value_reached,
	'over-current': over_current
	}

	dispatch_generic(ctx, 'current25-bricklet', callbacks, argv)

class DCBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 1; re[4] = 4; re[5] = 1; re[6] = 4; re[7] = 1; re[8] = 4; re[9] = 1; re[10] = 1; re[11] = 1; re[12] = 4; re[13] = 4; re[14] = 1; re[15] = 3; re[16] = 1; re[17] = 4; re[18] = 1; re[19] = 3; re[20] = 1; re[241] = 1; re[242] = 1; re[243] = 4; re[255] = 1
		cf = self.callback_formats
		cf[21] = 'H'; cf[22] = ''; cf[23] = 'h'; cf[24] = 'h'

def call_dc_brick(ctx, argv):
	prog_prefix = 'call dc-brick <uid>'

	def set_velocity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-velocity')

		parser.add_argument('velocity', type=convert_int, help='int', metavar='<velocity>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 1, (args.velocity,), 'h', '', None, args.expect_response, [], [])

	def get_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-velocity')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 2, (), '', 'h', args.execute, False, ['velocity'], [None])

	def get_current_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-velocity')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 3, (), '', 'h', args.execute, False, ['velocity'], [None])

	def set_acceleration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration')

		parser.add_argument('acceleration', type=convert_int, help='int', metavar='<acceleration>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 4, (args.acceleration,), 'H', '', None, args.expect_response, [], [])

	def get_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 5, (), '', 'H', args.execute, False, ['acceleration'], [None])

	def set_pwm_frequency(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-pwm-frequency')

		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 6, (args.frequency,), 'H', '', None, args.expect_response, [], [])

	def get_pwm_frequency(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pwm-frequency')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 7, (), '', 'H', args.execute, False, ['frequency'], [None])

	def full_brake(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' full-brake')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 8, (), '', '', None, args.expect_response, [], [])

	def get_stack_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-input-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 9, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_external_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-external-input-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 10, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_current_consumption(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-consumption')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 11, (), '', 'H', args.execute, False, ['voltage'], [None])

	def enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 12, (), '', '', None, args.expect_response, [], [])

	def disable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 13, (), '', '', None, args.expect_response, [], [])

	def is_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-enabled')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 14, (), '', '?', args.execute, False, ['enabled'], [None])

	def set_minimum_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-minimum-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 15, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_minimum_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-minimum-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 16, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_drive_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-drive-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'drive-brake': 0, 'drive-coast': 1}), help='int (drive-brake: 0, drive-coast: 1)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 17, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_drive_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-drive-mode')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 18, (), '', 'B', args.execute, False, ['mode'], [{0: 'drive-brake', 1: 'drive-coast'}])

	def set_current_velocity_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-velocity-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 19, (args.period,), 'H', '', None, args.expect_response, [], [])

	def get_current_velocity_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-velocity-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 20, (), '', 'H', args.execute, False, ['period'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_send_request(ctx, DCBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DCBrick, argv)

	functions = {
	'set-velocity': set_velocity,
	'get-velocity': get_velocity,
	'get-current-velocity': get_current_velocity,
	'set-acceleration': set_acceleration,
	'get-acceleration': get_acceleration,
	'set-pwm-frequency': set_pwm_frequency,
	'get-pwm-frequency': get_pwm_frequency,
	'full-brake': full_brake,
	'get-stack-input-voltage': get_stack_input_voltage,
	'get-external-input-voltage': get_external_input_voltage,
	'get-current-consumption': get_current_consumption,
	'enable': enable,
	'disable': disable,
	'is-enabled': is_enabled,
	'set-minimum-voltage': set_minimum_voltage,
	'get-minimum-voltage': get_minimum_voltage,
	'set-drive-mode': set_drive_mode,
	'get-drive-mode': get_drive_mode,
	'set-current-velocity-period': set_current_velocity_period,
	'get-current-velocity-period': get_current_velocity_period,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'dc-brick', functions, argv)

def dispatch_dc_brick(ctx, argv):
	prog_prefix = 'dispatch dc-brick <uid>'

	def under_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' under-voltage')

		args = parser.parse_args(argv)

		device_callback(ctx, DCBrick, 21, args.execute, ['voltage'])

	def emergency_shutdown(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' emergency-shutdown')

		args = parser.parse_args(argv)

		device_callback(ctx, DCBrick, 22, args.execute, [])

	def velocity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' velocity-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, DCBrick, 23, args.execute, ['velocity'])

	def current_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-velocity')

		args = parser.parse_args(argv)

		device_callback(ctx, DCBrick, 24, args.execute, ['velocity'])

	callbacks = {
	'under-voltage': under_voltage,
	'emergency-shutdown': emergency_shutdown,
	'velocity-reached': velocity_reached,
	'current-velocity': current_velocity
	}

	dispatch_generic(ctx, 'dc-brick', callbacks, argv)

class DistanceIRBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'H'; cf[16] = 'H'; cf[17] = 'H'; cf[18] = 'H'

def call_distance_ir_bricklet(ctx, argv):
	prog_prefix = 'call distance-ir-bricklet <uid>'

	def get_distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 1, (), '', 'H', args.execute, False, ['distance'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_sampling_point(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sampling-point')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('distance', type=convert_int, help='int', metavar='<distance>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 3, (args.position, args.distance), 'B H', '', None, args.expect_response, [], [])

	def get_sampling_point(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sampling-point')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 4, (args.position,), 'B', 'H', args.execute, False, ['distance'], [None])

	def set_distance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_distance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_distance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 9, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_distance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 10, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 11, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 12, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceIRBricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DistanceIRBricklet, argv)

	functions = {
	'get-distance': get_distance,
	'get-analog-value': get_analog_value,
	'set-sampling-point': set_sampling_point,
	'get-sampling-point': get_sampling_point,
	'set-distance-callback-period': set_distance_callback_period,
	'get-distance-callback-period': get_distance_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-distance-callback-threshold': set_distance_callback_threshold,
	'get-distance-callback-threshold': get_distance_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'distance-ir-bricklet', functions, argv)

def dispatch_distance_ir_bricklet(ctx, argv):
	prog_prefix = 'dispatch distance-ir-bricklet <uid>'

	def distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance')

		args = parser.parse_args(argv)

		device_callback(ctx, DistanceIRBricklet, 15, args.execute, ['distance'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, DistanceIRBricklet, 16, args.execute, ['value'])

	def distance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, DistanceIRBricklet, 17, args.execute, ['distance'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, DistanceIRBricklet, 18, args.execute, ['value'])

	callbacks = {
	'distance': distance,
	'analog-value': analog_value,
	'distance-reached': distance_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'distance-ir-bricklet', callbacks, argv)

class DistanceUSBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[10] = 4; re[11] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'

def call_distance_us_bricklet(ctx, argv):
	prog_prefix = 'call distance-us-bricklet <uid>'

	def get_distance_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceUSBricklet, 1, (), '', 'H', args.execute, False, ['distance'], [None])

	def set_distance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceUSBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_distance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceUSBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_distance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceUSBricklet, 4, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_distance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceUSBricklet, 5, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceUSBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceUSBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceUSBricklet, 10, (args.average,), 'B', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_send_request(ctx, DistanceUSBricklet, 11, (), '', 'B', args.execute, False, ['average'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DistanceUSBricklet, argv)

	functions = {
	'get-distance-value': get_distance_value,
	'set-distance-callback-period': set_distance_callback_period,
	'get-distance-callback-period': get_distance_callback_period,
	'set-distance-callback-threshold': set_distance_callback_threshold,
	'get-distance-callback-threshold': get_distance_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'get-identity': get_identity
	}

	call_generic(ctx, 'distance-us-bricklet', functions, argv)

def dispatch_distance_us_bricklet(ctx, argv):
	prog_prefix = 'dispatch distance-us-bricklet <uid>'

	def distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance')

		args = parser.parse_args(argv)

		device_callback(ctx, DistanceUSBricklet, 8, args.execute, ['distance'])

	def distance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, DistanceUSBricklet, 9, args.execute, ['distance'])

	callbacks = {
	'distance': distance,
	'distance-reached': distance_reached
	}

	dispatch_generic(ctx, 'distance-us-bricklet', callbacks, argv)

class DualButtonBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 1; re[5] = 4; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'B B B B'

def call_dual_button_bricklet(ctx, argv):
	prog_prefix = 'call dual-button-bricklet <uid>'

	def set_led_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-led-state')

		parser.add_argument('led_l', type=create_symbol_converter(ctx, convert_int, {'on': 2, 'auto-toggle-on': 0, 'off': 3, 'auto-toggle-off': 1}), help='int (auto-toggle-on: 0, auto-toggle-off: 1, on: 2, off: 3)', metavar='<led-l>')
		parser.add_argument('led_r', type=create_symbol_converter(ctx, convert_int, {'on': 2, 'auto-toggle-on': 0, 'off': 3, 'auto-toggle-off': 1}), help='int (auto-toggle-on: 0, auto-toggle-off: 1, on: 2, off: 3)', metavar='<led-r>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DualButtonBricklet, 1, (args.led_l, args.led_r), 'B B', '', None, args.expect_response, [], [])

	def get_led_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-led-state')

		args = parser.parse_args(argv)

		device_send_request(ctx, DualButtonBricklet, 2, (), '', 'B B', args.execute, False, ['led-l', 'led-r'], [{0: 'auto-toggle-on', 1: 'auto-toggle-off', 2: 'on', 3: 'off'}, {0: 'auto-toggle-on', 1: 'auto-toggle-off', 2: 'on', 3: 'off'}])

	def get_button_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-button-state')

		args = parser.parse_args(argv)

		device_send_request(ctx, DualButtonBricklet, 3, (), '', 'B B', args.execute, False, ['button-l', 'button-r'], [{0: 'pressed', 1: 'released'}, {0: 'pressed', 1: 'released'}])

	def set_selected_led_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-led-state')

		parser.add_argument('led', type=create_symbol_converter(ctx, convert_int, {'right': 1, 'left': 0}), help='int (left: 0, right: 1)', metavar='<led>')
		parser.add_argument('state', type=create_symbol_converter(ctx, convert_int, {'on': 2, 'auto-toggle-on': 0, 'off': 3, 'auto-toggle-off': 1}), help='int (auto-toggle-on: 0, auto-toggle-off: 1, on: 2, off: 3)', metavar='<state>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DualButtonBricklet, 5, (args.led, args.state), 'B B', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DualButtonBricklet, argv)

	functions = {
	'set-led-state': set_led_state,
	'get-led-state': get_led_state,
	'get-button-state': get_button_state,
	'set-selected-led-state': set_selected_led_state,
	'get-identity': get_identity
	}

	call_generic(ctx, 'dual-button-bricklet', functions, argv)

def dispatch_dual_button_bricklet(ctx, argv):
	prog_prefix = 'dispatch dual-button-bricklet <uid>'

	def state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' state-changed')

		args = parser.parse_args(argv)

		device_callback(ctx, DualButtonBricklet, 4, args.execute, ['button-l', 'button-r', 'led-l', 'led-r'])

	callbacks = {
	'state-changed': state_changed
	}

	dispatch_generic(ctx, 'dual-button-bricklet', callbacks, argv)

class DualRelayBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 4; re[4] = 1; re[6] = 4; re[255] = 1
		cf = self.callback_formats
		cf[5] = 'B ?'

def call_dual_relay_bricklet(ctx, argv):
	prog_prefix = 'call dual-relay-bricklet <uid>'

	def set_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-state')

		parser.add_argument('relay1', type=convert_bool, help='bool', metavar='<relay1>')
		parser.add_argument('relay2', type=convert_bool, help='bool', metavar='<relay2>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DualRelayBricklet, 1, (args.relay1, args.relay2), '? ?', '', None, args.expect_response, [], [])

	def get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-state')

		args = parser.parse_args(argv)

		device_send_request(ctx, DualRelayBricklet, 2, (), '', '? ?', args.execute, False, ['relay1', 'relay2'], [None, None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('relay', type=convert_int, help='int', metavar='<relay>')
		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DualRelayBricklet, 3, (args.relay, args.state, args.time), 'B ? I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('relay', type=convert_int, help='int', metavar='<relay>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DualRelayBricklet, 4, (args.relay,), 'B', '? I I', args.execute, False, ['state', 'time', 'time-remaining'], [None, None, None])

	def set_selected_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-state')

		parser.add_argument('relay', type=convert_int, help='int', metavar='<relay>')
		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')

		args = parser.parse_args(argv)

		device_send_request(ctx, DualRelayBricklet, 6, (args.relay, args.state), 'B ?', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DualRelayBricklet, argv)

	functions = {
	'set-state': set_state,
	'get-state': get_state,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-selected-state': set_selected_state,
	'get-identity': get_identity
	}

	call_generic(ctx, 'dual-relay-bricklet', functions, argv)

def dispatch_dual_relay_bricklet(ctx, argv):
	prog_prefix = 'dispatch dual-relay-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_callback(ctx, DualRelayBricklet, 5, args.execute, ['relay', 'state'])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'dual-relay-bricklet', callbacks, argv)

class GPSBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 1; re[5] = 1; re[6] = 4; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[255] = 1
		cf = self.callback_formats
		cf[17] = 'I c I c H H H H'; cf[18] = 'B B B'; cf[19] = 'I I'; cf[20] = 'I I'; cf[21] = 'I I'

def call_gps_bricklet(ctx, argv):
	prog_prefix = 'call gps-bricklet <uid>'

	def get_coordinates(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-coordinates')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 1, (), '', 'I c I c H H H H', args.execute, False, ['latitude', 'ns', 'longitude', 'ew', 'pdop', 'hdop', 'vdop', 'epe'], [None, None, None, None, None, None, None, None])

	def get_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 2, (), '', 'B B B', args.execute, False, ['fix', 'satellites-view', 'satellites-used'], [{1: 'no-fix', 2: '2d-fix', 3: '3d-fix'}, None, None])

	def get_altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 3, (), '', 'I I', args.execute, False, ['altitude', 'geoidal-separation'], [None, None])

	def get_motion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motion')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 4, (), '', 'I I', args.execute, False, ['course', 'speed'], [None, None])

	def get_date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 5, (), '', 'I I', args.execute, False, ['date', 'time'], [None, None])

	def restart(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' restart')

		parser.add_argument('restart_type', type=create_symbol_converter(ctx, convert_int, {'factory-reset': 3, 'cold-start': 2, 'warm-start': 1, 'hot-start': 0}), help='int (hot-start: 0, warm-start: 1, cold-start: 2, factory-reset: 3)', metavar='<restart-type>')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 6, (args.restart_type,), 'B', '', None, args.expect_response, [], [])

	def set_coordinates_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-coordinates-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_coordinates_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-coordinates-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_status_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 9, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_status_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 10, (), '', 'I', args.execute, False, ['period'], [None])

	def set_altitude_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-altitude-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 11, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_altitude_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 12, (), '', 'I', args.execute, False, ['period'], [None])

	def set_motion_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-motion-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 13, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_motion_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motion-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 14, (), '', 'I', args.execute, False, ['period'], [None])

	def set_date_time_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-date-time-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 15, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_date_time_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, GPSBricklet, 16, (), '', 'I', args.execute, False, ['period'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, GPSBricklet, argv)

	functions = {
	'get-coordinates': get_coordinates,
	'get-status': get_status,
	'get-altitude': get_altitude,
	'get-motion': get_motion,
	'get-date-time': get_date_time,
	'restart': restart,
	'set-coordinates-callback-period': set_coordinates_callback_period,
	'get-coordinates-callback-period': get_coordinates_callback_period,
	'set-status-callback-period': set_status_callback_period,
	'get-status-callback-period': get_status_callback_period,
	'set-altitude-callback-period': set_altitude_callback_period,
	'get-altitude-callback-period': get_altitude_callback_period,
	'set-motion-callback-period': set_motion_callback_period,
	'get-motion-callback-period': get_motion_callback_period,
	'set-date-time-callback-period': set_date_time_callback_period,
	'get-date-time-callback-period': get_date_time_callback_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'gps-bricklet', functions, argv)

def dispatch_gps_bricklet(ctx, argv):
	prog_prefix = 'dispatch gps-bricklet <uid>'

	def coordinates(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' coordinates')

		args = parser.parse_args(argv)

		device_callback(ctx, GPSBricklet, 17, args.execute, ['latitude', 'ns', 'longitude', 'ew', 'pdop', 'hdop', 'vdop', 'epe'])

	def status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' status')

		args = parser.parse_args(argv)

		device_callback(ctx, GPSBricklet, 18, args.execute, ['fix', 'satellites-view', 'satellites-used'])

	def altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' altitude')

		args = parser.parse_args(argv)

		device_callback(ctx, GPSBricklet, 19, args.execute, ['altitude', 'geoidal-separation'])

	def motion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' motion')

		args = parser.parse_args(argv)

		device_callback(ctx, GPSBricklet, 20, args.execute, ['course', 'speed'])

	def date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' date-time')

		args = parser.parse_args(argv)

		device_callback(ctx, GPSBricklet, 21, args.execute, ['date', 'time'])

	callbacks = {
	'coordinates': coordinates,
	'status': status,
	'altitude': altitude,
	'motion': motion,
	'date-time': date_time
	}

	dispatch_generic(ctx, 'gps-bricklet', callbacks, argv)

class HallEffectBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = 'I ?'

def call_hall_effect_bricklet(ctx, argv):
	prog_prefix = 'call hall-effect-bricklet <uid>'

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, HallEffectBricklet, 1, (), '', '?', args.execute, False, ['value'], [None])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_send_request(ctx, HallEffectBricklet, 2, (args.reset_counter,), '?', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-config')

		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'both': 2, 'falling': 1, 'rising': 0}), help='int (rising: 0, falling: 1, both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, HallEffectBricklet, 3, (args.edge_type, args.debounce), 'B B', '', None, args.expect_response, [], [])

	def get_edge_count_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-config')

		args = parser.parse_args(argv)

		device_send_request(ctx, HallEffectBricklet, 4, (), '', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'rising', 1: 'falling', 2: 'both'}, None])

	def set_edge_interrupt(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-interrupt')

		parser.add_argument('edges', type=convert_int, help='int', metavar='<edges>')

		args = parser.parse_args(argv)

		device_send_request(ctx, HallEffectBricklet, 5, (args.edges,), 'I', '', None, args.expect_response, [], [])

	def get_edge_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-interrupt')

		args = parser.parse_args(argv)

		device_send_request(ctx, HallEffectBricklet, 6, (), '', 'I', args.execute, False, ['edges'], [None])

	def set_edge_count_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, HallEffectBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_edge_count_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, HallEffectBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def edge_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' edge-interrupt')

		args = parser.parse_args(argv)

		device_send_request(ctx, HallEffectBricklet, 9, (), '', 'I ?', args.execute, False, ['count', 'value'], [None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, HallEffectBricklet, argv)

	functions = {
	'get-value': get_value,
	'get-edge-count': get_edge_count,
	'set-edge-count-config': set_edge_count_config,
	'get-edge-count-config': get_edge_count_config,
	'set-edge-interrupt': set_edge_interrupt,
	'get-edge-interrupt': get_edge_interrupt,
	'set-edge-count-callback-period': set_edge_count_callback_period,
	'get-edge-count-callback-period': get_edge_count_callback_period,
	'edge-interrupt': edge_interrupt,
	'get-identity': get_identity
	}

	call_generic(ctx, 'hall-effect-bricklet', functions, argv)

def dispatch_hall_effect_bricklet(ctx, argv):
	prog_prefix = 'dispatch hall-effect-bricklet <uid>'

	def edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' edge-count')

		args = parser.parse_args(argv)

		device_callback(ctx, HallEffectBricklet, 10, args.execute, ['count', 'value'])

	callbacks = {
	'edge-count': edge_count
	}

	dispatch_generic(ctx, 'hall-effect-bricklet', callbacks, argv)

class HumidityBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'

def call_humidity_bricklet(ctx, argv):
	prog_prefix = 'call humidity-bricklet <uid>'

	def get_humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 1, (), '', 'H', args.execute, False, ['humidity'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_humidity_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-humidity-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_humidity_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_humidity_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-humidity-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 7, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_humidity_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 8, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, HumidityBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, HumidityBricklet, argv)

	functions = {
	'get-humidity': get_humidity,
	'get-analog-value': get_analog_value,
	'set-humidity-callback-period': set_humidity_callback_period,
	'get-humidity-callback-period': get_humidity_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-humidity-callback-threshold': set_humidity_callback_threshold,
	'get-humidity-callback-threshold': get_humidity_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'humidity-bricklet', functions, argv)

def dispatch_humidity_bricklet(ctx, argv):
	prog_prefix = 'dispatch humidity-bricklet <uid>'

	def humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' humidity')

		args = parser.parse_args(argv)

		device_callback(ctx, HumidityBricklet, 13, args.execute, ['humidity'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, HumidityBricklet, 14, args.execute, ['value'])

	def humidity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' humidity-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, HumidityBricklet, 15, args.execute, ['humidity'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, HumidityBricklet, 16, args.execute, ['value'])

	callbacks = {
	'humidity': humidity,
	'analog-value': analog_value,
	'humidity-reached': humidity_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'humidity-bricklet', callbacks, argv)

class IMUBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 1; re[5] = 1; re[6] = 1; re[7] = 1; re[8] = 4; re[9] = 4; re[10] = 1; re[11] = 4; re[12] = 1; re[13] = 4; re[14] = 1; re[15] = 4; re[16] = 1; re[17] = 4; re[18] = 1; re[19] = 3; re[20] = 1; re[21] = 3; re[22] = 1; re[23] = 3; re[24] = 1; re[25] = 3; re[26] = 1; re[27] = 3; re[28] = 1; re[29] = 3; re[30] = 1; re[37] = 4; re[38] = 4; re[39] = 1; re[241] = 1; re[242] = 1; re[243] = 4; re[255] = 1
		cf = self.callback_formats
		cf[31] = 'h h h'; cf[32] = 'h h h'; cf[33] = 'h h h'; cf[34] = 'h h h h h h h h h h'; cf[35] = 'h h h'; cf[36] = 'f f f f'

def call_imu_brick(ctx, argv):
	prog_prefix = 'call imu-brick <uid>'

	def get_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 1, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_magnetic_field(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-field')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 2, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_angular_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-angular-velocity')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 3, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 4, (), '', 'h h h h h h h h h h', args.execute, False, ['acc-x', 'acc-y', 'acc-z', 'mag-x', 'mag-y', 'mag-z', 'ang-x', 'ang-y', 'ang-z', 'temperature'], [None, None, None, None, None, None, None, None, None, None])

	def get_orientation(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-orientation')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 5, (), '', 'h h h', args.execute, False, ['roll', 'pitch', 'yaw'], [None, None, None])

	def get_quaternion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-quaternion')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 6, (), '', 'f f f f', args.execute, False, ['x', 'y', 'z', 'w'], [None, None, None, None])

	def get_imu_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-imu-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 7, (), '', 'h', args.execute, False, ['temperature'], [None])

	def leds_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' leds-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 8, (), '', '', None, args.expect_response, [], [])

	def leds_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' leds-off')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 9, (), '', '', None, args.expect_response, [], [])

	def are_leds_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' are-leds-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 10, (), '', '?', args.execute, False, ['leds'], [None])

	def set_acceleration_range(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration-range')

		parser.add_argument('range', type=convert_int, help='int', metavar='<range>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 11, (args.range,), 'B', '', None, args.expect_response, [], [])

	def get_acceleration_range(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration-range')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 12, (), '', 'B', args.execute, False, ['range'], [None])

	def set_magnetometer_range(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-magnetometer-range')

		parser.add_argument('range', type=convert_int, help='int', metavar='<range>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 13, (args.range,), 'B', '', None, args.expect_response, [], [])

	def get_magnetometer_range(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetometer-range')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 14, (), '', 'B', args.execute, False, ['range'], [None])

	def set_convergence_speed(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-convergence-speed')

		parser.add_argument('speed', type=convert_int, help='int', metavar='<speed>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 15, (args.speed,), 'H', '', None, args.expect_response, [], [])

	def get_convergence_speed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-convergence-speed')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 16, (), '', 'H', args.execute, False, ['speed'], [None])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('typ', type=create_symbol_converter(ctx, convert_int, {'gyroscope-bias': 5, 'gyroscope-gain': 4, 'accelerometer-gain': 0, 'accelerometer-bias': 1, 'magnetometer-bias': 3, 'magnetometer-gain': 2}), help='int (accelerometer-gain: 0, accelerometer-bias: 1, magnetometer-gain: 2, magnetometer-bias: 3, gyroscope-gain: 4, gyroscope-bias: 5)', metavar='<typ>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, 10), help=get_array_type_name(ctx, 'int', 10), metavar='<data>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 17, (args.typ, args.data), 'B 10h', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		parser.add_argument('typ', type=create_symbol_converter(ctx, convert_int, {'gyroscope-bias': 5, 'gyroscope-gain': 4, 'accelerometer-gain': 0, 'accelerometer-bias': 1, 'magnetometer-bias': 3, 'magnetometer-gain': 2}), help='int (accelerometer-gain: 0, accelerometer-bias: 1, magnetometer-gain: 2, magnetometer-bias: 3, gyroscope-gain: 4, gyroscope-bias: 5)', metavar='<typ>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 18, (args.typ,), 'B', '10h', args.execute, False, ['data'], [None])

	def set_acceleration_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 19, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_acceleration_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 20, (), '', 'I', args.execute, False, ['period'], [None])

	def set_magnetic_field_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-magnetic-field-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 21, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_magnetic_field_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-field-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 22, (), '', 'I', args.execute, False, ['period'], [None])

	def set_angular_velocity_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-angular-velocity-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 23, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_angular_velocity_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-angular-velocity-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 24, (), '', 'I', args.execute, False, ['period'], [None])

	def set_all_data_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-data-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 25, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_all_data_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 26, (), '', 'I', args.execute, False, ['period'], [None])

	def set_orientation_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-orientation-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 27, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_orientation_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-orientation-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 28, (), '', 'I', args.execute, False, ['period'], [None])

	def set_quaternion_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-quaternion-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 29, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_quaternion_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-quaternion-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 30, (), '', 'I', args.execute, False, ['period'], [None])

	def orientation_calculation_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' orientation-calculation-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 37, (), '', '', None, args.expect_response, [], [])

	def orientation_calculation_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' orientation-calculation-off')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 38, (), '', '', None, args.expect_response, [], [])

	def is_orientation_calculation_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-orientation-calculation-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 39, (), '', '?', args.execute, False, ['orientation-calculation-on'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_send_request(ctx, IMUBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IMUBrick, argv)

	functions = {
	'get-acceleration': get_acceleration,
	'get-magnetic-field': get_magnetic_field,
	'get-angular-velocity': get_angular_velocity,
	'get-all-data': get_all_data,
	'get-orientation': get_orientation,
	'get-quaternion': get_quaternion,
	'get-imu-temperature': get_imu_temperature,
	'leds-on': leds_on,
	'leds-off': leds_off,
	'are-leds-on': are_leds_on,
	'set-acceleration-range': set_acceleration_range,
	'get-acceleration-range': get_acceleration_range,
	'set-magnetometer-range': set_magnetometer_range,
	'get-magnetometer-range': get_magnetometer_range,
	'set-convergence-speed': set_convergence_speed,
	'get-convergence-speed': get_convergence_speed,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'set-acceleration-period': set_acceleration_period,
	'get-acceleration-period': get_acceleration_period,
	'set-magnetic-field-period': set_magnetic_field_period,
	'get-magnetic-field-period': get_magnetic_field_period,
	'set-angular-velocity-period': set_angular_velocity_period,
	'get-angular-velocity-period': get_angular_velocity_period,
	'set-all-data-period': set_all_data_period,
	'get-all-data-period': get_all_data_period,
	'set-orientation-period': set_orientation_period,
	'get-orientation-period': get_orientation_period,
	'set-quaternion-period': set_quaternion_period,
	'get-quaternion-period': get_quaternion_period,
	'orientation-calculation-on': orientation_calculation_on,
	'orientation-calculation-off': orientation_calculation_off,
	'is-orientation-calculation-on': is_orientation_calculation_on,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'imu-brick', functions, argv)

def dispatch_imu_brick(ctx, argv):
	prog_prefix = 'dispatch imu-brick <uid>'

	def acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' acceleration')

		args = parser.parse_args(argv)

		device_callback(ctx, IMUBrick, 31, args.execute, ['x', 'y', 'z'])

	def magnetic_field(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' magnetic-field')

		args = parser.parse_args(argv)

		device_callback(ctx, IMUBrick, 32, args.execute, ['x', 'y', 'z'])

	def angular_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' angular-velocity')

		args = parser.parse_args(argv)

		device_callback(ctx, IMUBrick, 33, args.execute, ['x', 'y', 'z'])

	def all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-data')

		args = parser.parse_args(argv)

		device_callback(ctx, IMUBrick, 34, args.execute, ['acc-x', 'acc-y', 'acc-z', 'mag-x', 'mag-y', 'mag-z', 'ang-x', 'ang-y', 'ang-z', 'temperature'])

	def orientation(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' orientation')

		args = parser.parse_args(argv)

		device_callback(ctx, IMUBrick, 35, args.execute, ['roll', 'pitch', 'yaw'])

	def quaternion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' quaternion')

		args = parser.parse_args(argv)

		device_callback(ctx, IMUBrick, 36, args.execute, ['x', 'y', 'z', 'w'])

	callbacks = {
	'acceleration': acceleration,
	'magnetic-field': magnetic_field,
	'angular-velocity': angular_velocity,
	'all-data': all_data,
	'orientation': orientation,
	'quaternion': quaternion
	}

	dispatch_generic(ctx, 'imu-brick', callbacks, argv)

class IndustrialDigitalIn4Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 4; re[3] = 1; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[10] = 1; re[11] = 4; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'H H'

def call_industrial_digital_in_4_bricklet(ctx, argv):
	prog_prefix = 'call industrial-digital-in-4-bricklet <uid>'

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 1, (), '', 'H', args.execute, False, ['value-mask'], [None])

	def set_group(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-group')

		parser.add_argument('group', type=create_array_converter(ctx, check_char, 4), help=get_array_type_name(ctx, 'char', 4), metavar='<group>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 2, (args.group,), '4c', '', None, args.expect_response, [], [])

	def get_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-group')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 3, (), '', '4c', args.execute, False, ['group'], [None])

	def get_available_for_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-available-for-group')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 4, (), '', 'B', args.execute, False, ['available'], [None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 5, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 6, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_interrupt(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-interrupt')

		parser.add_argument('interrupt_mask', type=convert_int, help='int', metavar='<interrupt-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 7, (args.interrupt_mask,), 'H', '', None, args.expect_response, [], [])

	def get_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-interrupt')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 8, (), '', 'H', args.execute, False, ['interrupt-mask'], [None])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')
		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 10, (args.pin, args.reset_counter), 'B ?', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-config')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'both': 2, 'falling': 1, 'rising': 0}), help='int (rising: 0, falling: 1, both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 11, (args.selection_mask, args.edge_type, args.debounce), 'H B B', '', None, args.expect_response, [], [])

	def get_edge_count_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-config')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalIn4Bricklet, 12, (args.pin,), 'B', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'rising', 1: 'falling', 2: 'both'}, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDigitalIn4Bricklet, argv)

	functions = {
	'get-value': get_value,
	'set-group': set_group,
	'get-group': get_group,
	'get-available-for-group': get_available_for_group,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-interrupt': set_interrupt,
	'get-interrupt': get_interrupt,
	'get-edge-count': get_edge_count,
	'set-edge-count-config': set_edge_count_config,
	'get-edge-count-config': get_edge_count_config,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-digital-in-4-bricklet', functions, argv)

def dispatch_industrial_digital_in_4_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-digital-in-4-bricklet <uid>'

	def interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' interrupt')

		args = parser.parse_args(argv)

		device_callback(ctx, IndustrialDigitalIn4Bricklet, 9, args.execute, ['interrupt-mask', 'value-mask'])

	callbacks = {
	'interrupt': interrupt
	}

	dispatch_generic(ctx, 'industrial-digital-in-4-bricklet', callbacks, argv)

class IndustrialDigitalOut4Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 4; re[6] = 1; re[7] = 1; re[9] = 4; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H H'

def call_industrial_digital_out_4_bricklet(ctx, argv):
	prog_prefix = 'call industrial-digital-out-4-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalOut4Bricklet, 1, (args.value_mask,), 'H', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalOut4Bricklet, 2, (), '', 'H', args.execute, False, ['value-mask'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalOut4Bricklet, 3, (args.selection_mask, args.value_mask, args.time), 'H H I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalOut4Bricklet, 4, (args.pin,), 'B', 'H I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_group(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-group')

		parser.add_argument('group', type=create_array_converter(ctx, check_char, 4), help=get_array_type_name(ctx, 'char', 4), metavar='<group>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalOut4Bricklet, 5, (args.group,), '4c', '', None, args.expect_response, [], [])

	def get_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-group')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalOut4Bricklet, 6, (), '', '4c', args.execute, False, ['group'], [None])

	def get_available_for_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-available-for-group')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalOut4Bricklet, 7, (), '', 'B', args.execute, False, ['available'], [None])

	def set_selected_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-values')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDigitalOut4Bricklet, 9, (args.selection_mask, args.value_mask), 'H H', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDigitalOut4Bricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-group': set_group,
	'get-group': get_group,
	'get-available-for-group': get_available_for_group,
	'set-selected-values': set_selected_values,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-digital-out-4-bricklet', functions, argv)

def dispatch_industrial_digital_out_4_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-digital-out-4-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_callback(ctx, IndustrialDigitalOut4Bricklet, 8, args.execute, ['selection-mask', 'value-mask'])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'industrial-digital-out-4-bricklet', callbacks, argv)

class IndustrialDual020mABricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 4; re[9] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = 'B i'; cf[11] = 'B i'

def call_industrial_dual_0_20ma_bricklet(ctx, argv):
	prog_prefix = 'call industrial-dual-0-20ma-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDual020mABricklet, 1, (args.sensor,), 'B', 'i', args.execute, False, ['current'], [None])

	def set_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-period')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDual020mABricklet, 2, (args.sensor, args.period), 'B I', '', None, args.expect_response, [], [])

	def get_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-period')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDual020mABricklet, 3, (args.sensor,), 'B', 'I', args.execute, False, ['period'], [None])

	def set_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-threshold')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')
		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDual020mABricklet, 4, (args.sensor, args.option, args.min, args.max), 'B c i i', '', None, args.expect_response, [], [])

	def get_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-threshold')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDual020mABricklet, 5, (args.sensor,), 'B', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDual020mABricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDual020mABricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_sample_rate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sample-rate')

		parser.add_argument('rate', type=create_symbol_converter(ctx, convert_int, {'240-sps': 0, '15-sps': 2, '4-sps': 3, '60-sps': 1}), help='int (240-sps: 0, 60-sps: 1, 15-sps: 2, 4-sps: 3)', metavar='<rate>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDual020mABricklet, 8, (args.rate,), 'B', '', None, args.expect_response, [], [])

	def get_sample_rate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sample-rate')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialDual020mABricklet, 9, (), '', 'B', args.execute, False, ['rate'], [{0: '240-sps', 1: '60-sps', 2: '15-sps', 3: '4-sps'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDual020mABricklet, argv)

	functions = {
	'get-current': get_current,
	'set-current-callback-period': set_current_callback_period,
	'get-current-callback-period': get_current_callback_period,
	'set-current-callback-threshold': set_current_callback_threshold,
	'get-current-callback-threshold': get_current_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-sample-rate': set_sample_rate,
	'get-sample-rate': get_sample_rate,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-dual-0-20ma-bricklet', functions, argv)

def dispatch_industrial_dual_0_20ma_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-dual-0-20ma-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_callback(ctx, IndustrialDual020mABricklet, 10, args.execute, ['sensor', 'current'])

	def current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, IndustrialDual020mABricklet, 11, args.execute, ['sensor', 'current'])

	callbacks = {
	'current': current,
	'current-reached': current_reached
	}

	dispatch_generic(ctx, 'industrial-dual-0-20ma-bricklet', callbacks, argv)

class IndustrialQuadRelayBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 4; re[6] = 1; re[7] = 1; re[9] = 4; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H H'

def call_industrial_quad_relay_bricklet(ctx, argv):
	prog_prefix = 'call industrial-quad-relay-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialQuadRelayBricklet, 1, (args.value_mask,), 'H', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialQuadRelayBricklet, 2, (), '', 'H', args.execute, False, ['value-mask'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialQuadRelayBricklet, 3, (args.selection_mask, args.value_mask, args.time), 'H H I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialQuadRelayBricklet, 4, (args.pin,), 'B', 'H I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_group(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-group')

		parser.add_argument('group', type=create_array_converter(ctx, check_char, 4), help=get_array_type_name(ctx, 'char', 4), metavar='<group>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialQuadRelayBricklet, 5, (args.group,), '4c', '', None, args.expect_response, [], [])

	def get_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-group')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialQuadRelayBricklet, 6, (), '', '4c', args.execute, False, ['group'], [None])

	def get_available_for_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-available-for-group')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialQuadRelayBricklet, 7, (), '', 'B', args.execute, False, ['available'], [None])

	def set_selected_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-values')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IndustrialQuadRelayBricklet, 9, (args.selection_mask, args.value_mask), 'H H', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialQuadRelayBricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-group': set_group,
	'get-group': get_group,
	'get-available-for-group': get_available_for_group,
	'set-selected-values': set_selected_values,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-quad-relay-bricklet', functions, argv)

def dispatch_industrial_quad_relay_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-quad-relay-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_callback(ctx, IndustrialQuadRelayBricklet, 8, args.execute, ['selection-mask', 'value-mask'])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'industrial-quad-relay-bricklet', callbacks, argv)

class IO16Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[10] = 4; re[11] = 1; re[13] = 4; re[14] = 1; re[15] = 4; re[16] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'c B B'; cf[12] = 'c B B'

def call_io16_bricklet(ctx, argv):
	prog_prefix = 'call io16-bricklet <uid>'

	def set_port(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-port')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 1, (args.port, args.value_mask), 'c B', '', None, args.expect_response, [], [])

	def get_port(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-port')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 2, (args.port,), 'c', 'B', args.execute, False, ['value-mask'], [None])

	def set_port_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-port-configuration')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')
		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('direction', type=create_symbol_converter(ctx, check_char, {'out': 'o', 'in': 'i'}), help='char (in: i, out: o)', metavar='<direction>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 3, (args.port, args.selection_mask, args.direction, args.value), 'c B c ?', '', None, args.expect_response, [], [])

	def get_port_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-port-configuration')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 4, (args.port,), 'c', 'B B', args.execute, False, ['direction-mask', 'value-mask'], [None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 5, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 6, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_port_interrupt(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-port-interrupt')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')
		parser.add_argument('interrupt_mask', type=convert_int, help='int', metavar='<interrupt-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 7, (args.port, args.interrupt_mask), 'c B', '', None, args.expect_response, [], [])

	def get_port_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-port-interrupt')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 8, (args.port,), 'c', 'B', args.execute, False, ['interrupt-mask'], [None])

	def set_port_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-port-monoflop')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')
		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 10, (args.port, args.selection_mask, args.value_mask, args.time), 'c B B I', '', None, args.expect_response, [], [])

	def get_port_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-port-monoflop')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')
		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 11, (args.port, args.pin), 'c B', 'B I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_selected_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-values')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')
		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 13, (args.port, args.selection_mask, args.value_mask), 'c B B', '', None, args.expect_response, [], [])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')
		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 14, (args.pin, args.reset_counter), 'B ?', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-config')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')
		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'both': 2, 'falling': 1, 'rising': 0}), help='int (rising: 0, falling: 1, both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 15, (args.pin, args.edge_type, args.debounce), 'B B B', '', None, args.expect_response, [], [])

	def get_edge_count_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-config')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO16Bricklet, 16, (args.pin,), 'B', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'rising', 1: 'falling', 2: 'both'}, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IO16Bricklet, argv)

	functions = {
	'set-port': set_port,
	'get-port': get_port,
	'set-port-configuration': set_port_configuration,
	'get-port-configuration': get_port_configuration,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-port-interrupt': set_port_interrupt,
	'get-port-interrupt': get_port_interrupt,
	'set-port-monoflop': set_port_monoflop,
	'get-port-monoflop': get_port_monoflop,
	'set-selected-values': set_selected_values,
	'get-edge-count': get_edge_count,
	'set-edge-count-config': set_edge_count_config,
	'get-edge-count-config': get_edge_count_config,
	'get-identity': get_identity
	}

	call_generic(ctx, 'io16-bricklet', functions, argv)

def dispatch_io16_bricklet(ctx, argv):
	prog_prefix = 'dispatch io16-bricklet <uid>'

	def interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' interrupt')

		args = parser.parse_args(argv)

		device_callback(ctx, IO16Bricklet, 9, args.execute, ['port', 'interrupt-mask', 'value-mask'])

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_callback(ctx, IO16Bricklet, 12, args.execute, ['port', 'selection-mask', 'value-mask'])

	callbacks = {
	'interrupt': interrupt,
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'io16-bricklet', callbacks, argv)

class IO4Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[10] = 4; re[11] = 1; re[13] = 4; re[14] = 1; re[15] = 4; re[16] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'B B'; cf[12] = 'B B'

def call_io4_bricklet(ctx, argv):
	prog_prefix = 'call io4-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 1, (args.value_mask,), 'B', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 2, (), '', 'B', args.execute, False, ['value-mask'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('direction', type=create_symbol_converter(ctx, check_char, {'out': 'o', 'in': 'i'}), help='char (in: i, out: o)', metavar='<direction>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 3, (args.selection_mask, args.direction, args.value), 'B c ?', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 4, (), '', 'B B', args.execute, False, ['direction-mask', 'value-mask'], [None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 5, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 6, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_interrupt(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-interrupt')

		parser.add_argument('interrupt_mask', type=convert_int, help='int', metavar='<interrupt-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 7, (args.interrupt_mask,), 'B', '', None, args.expect_response, [], [])

	def get_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-interrupt')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 8, (), '', 'B', args.execute, False, ['interrupt-mask'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 10, (args.selection_mask, args.value_mask, args.time), 'B B I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 11, (args.pin,), 'B', 'B I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_selected_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-values')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 13, (args.selection_mask, args.value_mask), 'B B', '', None, args.expect_response, [], [])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')
		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 14, (args.pin, args.reset_counter), 'B ?', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-config')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'both': 2, 'falling': 1, 'rising': 0}), help='int (rising: 0, falling: 1, both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 15, (args.selection_mask, args.edge_type, args.debounce), 'B B B', '', None, args.expect_response, [], [])

	def get_edge_count_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-config')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_send_request(ctx, IO4Bricklet, 16, (args.pin,), 'B', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'rising', 1: 'falling', 2: 'both'}, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IO4Bricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-interrupt': set_interrupt,
	'get-interrupt': get_interrupt,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-selected-values': set_selected_values,
	'get-edge-count': get_edge_count,
	'set-edge-count-config': set_edge_count_config,
	'get-edge-count-config': get_edge_count_config,
	'get-identity': get_identity
	}

	call_generic(ctx, 'io4-bricklet', functions, argv)

def dispatch_io4_bricklet(ctx, argv):
	prog_prefix = 'dispatch io4-bricklet <uid>'

	def interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' interrupt')

		args = parser.parse_args(argv)

		device_callback(ctx, IO4Bricklet, 9, args.execute, ['interrupt-mask', 'value-mask'])

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_callback(ctx, IO4Bricklet, 12, args.execute, ['selection-mask', 'value-mask'])

	callbacks = {
	'interrupt': interrupt,
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'io4-bricklet', callbacks, argv)

class JoystickBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 4; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'h h'; cf[16] = 'H H'; cf[17] = 'h h'; cf[18] = 'H H'; cf[19] = ''; cf[20] = ''

def call_joystick_bricklet(ctx, argv):
	prog_prefix = 'call joystick-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 1, (), '', 'h h', args.execute, False, ['x', 'y'], [None, None])

	def is_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-pressed')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 2, (), '', '?', args.execute, False, ['pressed'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 3, (), '', 'H H', args.execute, False, ['x', 'y'], [None, None])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 4, (), '', '', None, args.expect_response, [], [])

	def set_position_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_position_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_position_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min_x', type=convert_int, help='int', metavar='<min-x>')
		parser.add_argument('max_x', type=convert_int, help='int', metavar='<max-x>')
		parser.add_argument('min_y', type=convert_int, help='int', metavar='<min-y>')
		parser.add_argument('max_y', type=convert_int, help='int', metavar='<max-y>')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 9, (args.option, args.min_x, args.max_x, args.min_y, args.max_y), 'c h h h h', '', None, args.expect_response, [], [])

	def get_position_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 10, (), '', 'c h h h h', args.execute, False, ['option', 'min-x', 'max-x', 'min-y', 'max-y'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min_x', type=convert_int, help='int', metavar='<min-x>')
		parser.add_argument('max_x', type=convert_int, help='int', metavar='<max-x>')
		parser.add_argument('min_y', type=convert_int, help='int', metavar='<min-y>')
		parser.add_argument('max_y', type=convert_int, help='int', metavar='<max-y>')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 11, (args.option, args.min_x, args.max_x, args.min_y, args.max_y), 'c H H H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 12, (), '', 'c H H H H', args.execute, False, ['option', 'min-x', 'max-x', 'min-y', 'max-y'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, JoystickBricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, JoystickBricklet, argv)

	functions = {
	'get-position': get_position,
	'is-pressed': is_pressed,
	'get-analog-value': get_analog_value,
	'calibrate': calibrate,
	'set-position-callback-period': set_position_callback_period,
	'get-position-callback-period': get_position_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-position-callback-threshold': set_position_callback_threshold,
	'get-position-callback-threshold': get_position_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'joystick-bricklet', functions, argv)

def dispatch_joystick_bricklet(ctx, argv):
	prog_prefix = 'dispatch joystick-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_callback(ctx, JoystickBricklet, 15, args.execute, ['x', 'y'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, JoystickBricklet, 16, args.execute, ['x', 'y'])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, JoystickBricklet, 17, args.execute, ['x', 'y'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, JoystickBricklet, 18, args.execute, ['x', 'y'])

	def pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' pressed')

		args = parser.parse_args(argv)

		device_callback(ctx, JoystickBricklet, 19, args.execute, [])

	def released(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' released')

		args = parser.parse_args(argv)

		device_callback(ctx, JoystickBricklet, 20, args.execute, [])

	callbacks = {
	'position': position,
	'analog-value': analog_value,
	'position-reached': position_reached,
	'analog-value-reached': analog_value_reached,
	'pressed': pressed,
	'released': released
	}

	dispatch_generic(ctx, 'joystick-bricklet', callbacks, argv)

class LCD16x2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 4; re[3] = 4; re[4] = 4; re[5] = 1; re[6] = 4; re[7] = 1; re[8] = 1; re[11] = 4; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'B'; cf[10] = 'B'

def call_lcd_16x2_bricklet(ctx, argv):
	prog_prefix = 'call lcd-16x2-bricklet <uid>'

	def write_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-line')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('text', type=create_string_checker(str, 16), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 1, (args.line, args.position, args.text), 'B B 16s', '', None, args.expect_response, [], [])

	def clear_display(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' clear-display')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 2, (), '', '', None, args.expect_response, [], [])

	def backlight_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' backlight-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def backlight_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' backlight-off')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 4, (), '', '', None, args.expect_response, [], [])

	def is_backlight_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-backlight-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 5, (), '', '?', args.execute, False, ['backlight'], [None])

	def set_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-config')

		parser.add_argument('cursor', type=convert_bool, help='bool', metavar='<cursor>')
		parser.add_argument('blinking', type=convert_bool, help='bool', metavar='<blinking>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 6, (args.cursor, args.blinking), '? ?', '', None, args.expect_response, [], [])

	def get_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-config')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 7, (), '', '? ?', args.execute, False, ['cursor', 'blinking'], [None, None])

	def is_button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-button-pressed')

		parser.add_argument('button', type=convert_int, help='int', metavar='<button>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 8, (args.button,), 'B', '?', args.execute, False, ['pressed'], [None])

	def set_custom_character(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-custom-character')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('character', type=create_array_converter(ctx, convert_int, 8), help=get_array_type_name(ctx, 'int', 8), metavar='<character>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 11, (args.index, args.character), 'B 8B', '', None, args.expect_response, [], [])

	def get_custom_character(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-custom-character')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD16x2Bricklet, 12, (args.index,), 'B', '8B', args.execute, False, ['character'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LCD16x2Bricklet, argv)

	functions = {
	'write-line': write_line,
	'clear-display': clear_display,
	'backlight-on': backlight_on,
	'backlight-off': backlight_off,
	'is-backlight-on': is_backlight_on,
	'set-config': set_config,
	'get-config': get_config,
	'is-button-pressed': is_button_pressed,
	'set-custom-character': set_custom_character,
	'get-custom-character': get_custom_character,
	'get-identity': get_identity
	}

	call_generic(ctx, 'lcd-16x2-bricklet', functions, argv)

def dispatch_lcd_16x2_bricklet(ctx, argv):
	prog_prefix = 'dispatch lcd-16x2-bricklet <uid>'

	def button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' button-pressed')

		args = parser.parse_args(argv)

		device_callback(ctx, LCD16x2Bricklet, 9, args.execute, ['button'])

	def button_released(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' button-released')

		args = parser.parse_args(argv)

		device_callback(ctx, LCD16x2Bricklet, 10, args.execute, ['button'])

	callbacks = {
	'button-pressed': button_pressed,
	'button-released': button_released
	}

	dispatch_generic(ctx, 'lcd-16x2-bricklet', callbacks, argv)

class LCD20x4Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 4; re[3] = 4; re[4] = 4; re[5] = 1; re[6] = 4; re[7] = 1; re[8] = 1; re[11] = 4; re[12] = 1; re[13] = 4; re[14] = 1; re[15] = 4; re[16] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'B'; cf[10] = 'B'

def call_lcd_20x4_bricklet(ctx, argv):
	prog_prefix = 'call lcd-20x4-bricklet <uid>'

	def write_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-line')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('text', type=create_string_checker(str, 20), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 1, (args.line, args.position, args.text), 'B B 20s', '', None, args.expect_response, [], [])

	def clear_display(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' clear-display')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 2, (), '', '', None, args.expect_response, [], [])

	def backlight_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' backlight-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def backlight_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' backlight-off')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 4, (), '', '', None, args.expect_response, [], [])

	def is_backlight_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-backlight-on')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 5, (), '', '?', args.execute, False, ['backlight'], [None])

	def set_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-config')

		parser.add_argument('cursor', type=convert_bool, help='bool', metavar='<cursor>')
		parser.add_argument('blinking', type=convert_bool, help='bool', metavar='<blinking>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 6, (args.cursor, args.blinking), '? ?', '', None, args.expect_response, [], [])

	def get_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-config')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 7, (), '', '? ?', args.execute, False, ['cursor', 'blinking'], [None, None])

	def is_button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-button-pressed')

		parser.add_argument('button', type=convert_int, help='int', metavar='<button>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 8, (args.button,), 'B', '?', args.execute, False, ['pressed'], [None])

	def set_custom_character(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-custom-character')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('character', type=create_array_converter(ctx, convert_int, 8), help=get_array_type_name(ctx, 'int', 8), metavar='<character>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 11, (args.index, args.character), 'B 8B', '', None, args.expect_response, [], [])

	def get_custom_character(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-custom-character')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 12, (args.index,), 'B', '8B', args.execute, False, ['character'], [None])

	def set_default_text(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-default-text')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('text', type=create_string_checker(str, 20), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 13, (args.line, args.text), 'B 20s', '', None, args.expect_response, [], [])

	def get_default_text(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-default-text')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 14, (args.line,), 'B', '20s', args.execute, False, ['text'], [None])

	def set_default_text_counter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-default-text-counter')

		parser.add_argument('counter', type=convert_int, help='int', metavar='<counter>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 15, (args.counter,), 'i', '', None, args.expect_response, [], [])

	def get_default_text_counter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-default-text-counter')

		args = parser.parse_args(argv)

		device_send_request(ctx, LCD20x4Bricklet, 16, (), '', 'i', args.execute, False, ['counter'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LCD20x4Bricklet, argv)

	functions = {
	'write-line': write_line,
	'clear-display': clear_display,
	'backlight-on': backlight_on,
	'backlight-off': backlight_off,
	'is-backlight-on': is_backlight_on,
	'set-config': set_config,
	'get-config': get_config,
	'is-button-pressed': is_button_pressed,
	'set-custom-character': set_custom_character,
	'get-custom-character': get_custom_character,
	'set-default-text': set_default_text,
	'get-default-text': get_default_text,
	'set-default-text-counter': set_default_text_counter,
	'get-default-text-counter': get_default_text_counter,
	'get-identity': get_identity
	}

	call_generic(ctx, 'lcd-20x4-bricklet', functions, argv)

def dispatch_lcd_20x4_bricklet(ctx, argv):
	prog_prefix = 'dispatch lcd-20x4-bricklet <uid>'

	def button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' button-pressed')

		args = parser.parse_args(argv)

		device_callback(ctx, LCD20x4Bricklet, 9, args.execute, ['button'])

	def button_released(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' button-released')

		args = parser.parse_args(argv)

		device_callback(ctx, LCD20x4Bricklet, 10, args.execute, ['button'])

	callbacks = {
	'button-pressed': button_pressed,
	'button-released': button_released
	}

	dispatch_generic(ctx, 'lcd-20x4-bricklet', callbacks, argv)

class LEDStripBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 1; re[7] = 4; re[8] = 1; re[9] = 4; re[10] = 1; re[255] = 1
		cf = self.callback_formats
		cf[6] = 'H'

def call_led_strip_bricklet(ctx, argv):
	prog_prefix = 'call led-strip-bricklet <uid>'

	def set_rgb_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rgb-values')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')
		parser.add_argument('r', type=create_array_converter(ctx, convert_int, 16), help=get_array_type_name(ctx, 'int', 16), metavar='<r>')
		parser.add_argument('g', type=create_array_converter(ctx, convert_int, 16), help=get_array_type_name(ctx, 'int', 16), metavar='<g>')
		parser.add_argument('b', type=create_array_converter(ctx, convert_int, 16), help=get_array_type_name(ctx, 'int', 16), metavar='<b>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LEDStripBricklet, 1, (args.index, args.length, args.r, args.g, args.b), 'H B 16B 16B 16B', '', None, args.expect_response, [], [])

	def get_rgb_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rgb-values')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LEDStripBricklet, 2, (args.index, args.length), 'H B', '16B 16B 16B', args.execute, False, ['r', 'g', 'b'], [None, None, None])

	def set_frame_duration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-frame-duration')

		parser.add_argument('duration', type=convert_int, help='int', metavar='<duration>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LEDStripBricklet, 3, (args.duration,), 'H', '', None, args.expect_response, [], [])

	def get_frame_duration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-frame-duration')

		args = parser.parse_args(argv)

		device_send_request(ctx, LEDStripBricklet, 4, (), '', 'H', args.execute, False, ['duration'], [None])

	def get_supply_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-supply-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, LEDStripBricklet, 5, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_clock_frequency(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-clock-frequency')

		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LEDStripBricklet, 7, (args.frequency,), 'I', '', None, args.expect_response, [], [])

	def get_clock_frequency(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-clock-frequency')

		args = parser.parse_args(argv)

		device_send_request(ctx, LEDStripBricklet, 8, (), '', 'I', args.execute, False, ['frequency'], [None])

	def set_chip_type(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chip-type')

		parser.add_argument('chip', type=create_symbol_converter(ctx, convert_int, {'ws2812': 2812, 'ws2811': 2811, 'ws2801': 2801}), help='int (ws2801: 2801, ws2811: 2811, ws2812: 2812)', metavar='<chip>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LEDStripBricklet, 9, (args.chip,), 'H', '', None, args.expect_response, [], [])

	def get_chip_type(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-type')

		args = parser.parse_args(argv)

		device_send_request(ctx, LEDStripBricklet, 10, (), '', 'H', args.execute, False, ['chip'], [{2801: 'ws2801', 2811: 'ws2811', 2812: 'ws2812'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LEDStripBricklet, argv)

	functions = {
	'set-rgb-values': set_rgb_values,
	'get-rgb-values': get_rgb_values,
	'set-frame-duration': set_frame_duration,
	'get-frame-duration': get_frame_duration,
	'get-supply-voltage': get_supply_voltage,
	'set-clock-frequency': set_clock_frequency,
	'get-clock-frequency': get_clock_frequency,
	'set-chip-type': set_chip_type,
	'get-chip-type': get_chip_type,
	'get-identity': get_identity
	}

	call_generic(ctx, 'led-strip-bricklet', functions, argv)

def dispatch_led_strip_bricklet(ctx, argv):
	prog_prefix = 'dispatch led-strip-bricklet <uid>'

	def frame_rendered(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-rendered')

		args = parser.parse_args(argv)

		device_callback(ctx, LEDStripBricklet, 6, args.execute, ['length'])

	callbacks = {
	'frame-rendered': frame_rendered
	}

	dispatch_generic(ctx, 'led-strip-bricklet', callbacks, argv)

class LineBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'

def call_line_bricklet(ctx, argv):
	prog_prefix = 'call line-bricklet <uid>'

	def get_reflectivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-reflectivity')

		args = parser.parse_args(argv)

		device_send_request(ctx, LineBricklet, 1, (), '', 'H', args.execute, False, ['reflectivity'], [None])

	def set_reflectivity_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-reflectivity-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LineBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_reflectivity_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-reflectivity-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, LineBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_reflectivity_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-reflectivity-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LineBricklet, 4, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_reflectivity_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-reflectivity-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, LineBricklet, 5, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LineBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, LineBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LineBricklet, argv)

	functions = {
	'get-reflectivity': get_reflectivity,
	'set-reflectivity-callback-period': set_reflectivity_callback_period,
	'get-reflectivity-callback-period': get_reflectivity_callback_period,
	'set-reflectivity-callback-threshold': set_reflectivity_callback_threshold,
	'get-reflectivity-callback-threshold': get_reflectivity_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'line-bricklet', functions, argv)

def dispatch_line_bricklet(ctx, argv):
	prog_prefix = 'dispatch line-bricklet <uid>'

	def reflectivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reflectivity')

		args = parser.parse_args(argv)

		device_callback(ctx, LineBricklet, 8, args.execute, ['reflectivity'])

	def reflectivity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reflectivity-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, LineBricklet, 9, args.execute, ['reflectivity'])

	callbacks = {
	'reflectivity': reflectivity,
	'reflectivity-reached': reflectivity_reached
	}

	dispatch_generic(ctx, 'line-bricklet', callbacks, argv)

class LinearPotiBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'

def call_linear_poti_bricklet(ctx, argv):
	prog_prefix = 'call linear-poti-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 1, (), '', 'H', args.execute, False, ['position'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_position_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_position_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_position_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 7, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_position_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 8, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, LinearPotiBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LinearPotiBricklet, argv)

	functions = {
	'get-position': get_position,
	'get-analog-value': get_analog_value,
	'set-position-callback-period': set_position_callback_period,
	'get-position-callback-period': get_position_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-position-callback-threshold': set_position_callback_threshold,
	'get-position-callback-threshold': get_position_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'linear-poti-bricklet', functions, argv)

def dispatch_linear_poti_bricklet(ctx, argv):
	prog_prefix = 'dispatch linear-poti-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_callback(ctx, LinearPotiBricklet, 13, args.execute, ['position'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, LinearPotiBricklet, 14, args.execute, ['value'])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, LinearPotiBricklet, 15, args.execute, ['position'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, LinearPotiBricklet, 16, args.execute, ['value'])

	callbacks = {
	'position': position,
	'analog-value': analog_value,
	'position-reached': position_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'linear-poti-bricklet', callbacks, argv)

class MasterBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 1; re[6] = 4; re[7] = 1; re[8] = 4; re[9] = 1; re[10] = 4; re[11] = 1; re[12] = 1; re[13] = 1; re[14] = 4; re[15] = 1; re[16] = 4; re[17] = 1; re[18] = 1; re[19] = 4; re[20] = 1; re[21] = 4; re[22] = 1; re[23] = 1; re[24] = 4; re[25] = 1; re[26] = 1; re[27] = 4; re[28] = 1; re[29] = 4; re[30] = 1; re[31] = 1; re[32] = 4; re[33] = 4; re[34] = 1; re[35] = 4; re[36] = 1; re[37] = 1; re[38] = 4; re[39] = 1; re[40] = 1; re[41] = 4; re[42] = 1; re[43] = 4; re[44] = 1; re[45] = 3; re[46] = 1; re[47] = 3; re[48] = 1; re[49] = 3; re[50] = 1; re[51] = 3; re[52] = 1; re[53] = 3; re[54] = 1; re[55] = 3; re[56] = 1; re[57] = 3; re[58] = 1; re[65] = 1; re[66] = 4; re[67] = 1; re[68] = 1; re[69] = 4; re[70] = 4; re[71] = 4; re[72] = 1; re[73] = 4; re[74] = 1; re[75] = 4; re[76] = 1; re[241] = 1; re[242] = 1; re[243] = 4; re[255] = 1
		cf = self.callback_formats
		cf[59] = 'H'; cf[60] = 'H'; cf[61] = 'H'; cf[62] = 'H'; cf[63] = 'H'; cf[64] = 'H'

def call_master_brick(ctx, argv):
	prog_prefix = 'call master-brick <uid>'

	def get_stack_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 1, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_stack_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-current')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 2, (), '', 'H', args.execute, False, ['current'], [None])

	def set_extension_type(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-extension-type')

		parser.add_argument('extension', type=convert_int, help='int', metavar='<extension>')
		parser.add_argument('exttype', type=create_symbol_converter(ctx, convert_int, {'chibi': 1, 'ethernet': 4, 'rs485': 2, 'wifi': 3}), help='int (chibi: 1, rs485: 2, wifi: 3, ethernet: 4)', metavar='<exttype>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 3, (args.extension, args.exttype), 'B I', '', None, args.expect_response, [], [])

	def get_extension_type(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-extension-type')

		parser.add_argument('extension', type=convert_int, help='int', metavar='<extension>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 4, (args.extension,), 'B', 'I', args.execute, False, ['exttype'], [{1: 'chibi', 2: 'rs485', 3: 'wifi', 4: 'ethernet'}])

	def is_chibi_present(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-chibi-present')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 5, (), '', '?', args.execute, False, ['present'], [None])

	def set_chibi_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-address')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 6, (args.address,), 'B', '', None, args.expect_response, [], [])

	def get_chibi_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-address')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 7, (), '', 'B', args.execute, False, ['address'], [None])

	def set_chibi_master_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-master-address')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 8, (args.address,), 'B', '', None, args.expect_response, [], [])

	def get_chibi_master_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-master-address')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 9, (), '', 'B', args.execute, False, ['address'], [None])

	def set_chibi_slave_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-slave-address')

		parser.add_argument('num', type=convert_int, help='int', metavar='<num>')
		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 10, (args.num, args.address), 'B B', '', None, args.expect_response, [], [])

	def get_chibi_slave_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-slave-address')

		parser.add_argument('num', type=convert_int, help='int', metavar='<num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 11, (args.num,), 'B', 'B', args.execute, False, ['address'], [None])

	def get_chibi_signal_strength(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-signal-strength')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 12, (), '', 'B', args.execute, False, ['signal-strength'], [None])

	def get_chibi_error_log(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-error-log')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 13, (), '', 'H H H H', args.execute, False, ['underrun', 'crc-error', 'no-ack', 'overflow'], [None, None, None, None])

	def set_chibi_frequency(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-frequency')

		parser.add_argument('frequency', type=create_symbol_converter(ctx, convert_int, {'oqpsk-780-mhz': 2, 'oqpsk-915-mhz': 1, 'bpsk40-915-mhz': 3, 'oqpsk-868-mhz': 0}), help='int (oqpsk-868-mhz: 0, oqpsk-915-mhz: 1, oqpsk-780-mhz: 2, bpsk40-915-mhz: 3)', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 14, (args.frequency,), 'B', '', None, args.expect_response, [], [])

	def get_chibi_frequency(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-frequency')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 15, (), '', 'B', args.execute, False, ['frequency'], [{0: 'oqpsk-868-mhz', 1: 'oqpsk-915-mhz', 2: 'oqpsk-780-mhz', 3: 'bpsk40-915-mhz'}])

	def set_chibi_channel(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-channel')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 16, (args.channel,), 'B', '', None, args.expect_response, [], [])

	def get_chibi_channel(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-channel')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 17, (), '', 'B', args.execute, False, ['channel'], [None])

	def is_rs485_present(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-rs485-present')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 18, (), '', '?', args.execute, False, ['present'], [None])

	def set_rs485_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rs485-address')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 19, (args.address,), 'B', '', None, args.expect_response, [], [])

	def get_rs485_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rs485-address')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 20, (), '', 'B', args.execute, False, ['address'], [None])

	def set_rs485_slave_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rs485-slave-address')

		parser.add_argument('num', type=convert_int, help='int', metavar='<num>')
		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 21, (args.num, args.address), 'B B', '', None, args.expect_response, [], [])

	def get_rs485_slave_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rs485-slave-address')

		parser.add_argument('num', type=convert_int, help='int', metavar='<num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 22, (args.num,), 'B', 'B', args.execute, False, ['address'], [None])

	def get_rs485_error_log(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rs485-error-log')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 23, (), '', 'H', args.execute, False, ['crc-error'], [None])

	def set_rs485_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rs485-configuration')

		parser.add_argument('speed', type=convert_int, help='int', metavar='<speed>')
		parser.add_argument('parity', type=create_symbol_converter(ctx, check_char, {'even': 'e', 'none': 'n', 'odd': 'o'}), help='char (none: n, even: e, odd: o)', metavar='<parity>')
		parser.add_argument('stopbits', type=convert_int, help='int', metavar='<stopbits>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 24, (args.speed, args.parity, args.stopbits), 'I c B', '', None, args.expect_response, [], [])

	def get_rs485_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rs485-configuration')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 25, (), '', 'I c B', args.execute, False, ['speed', 'parity', 'stopbits'], [None, {'e': 'even', 'o': 'odd', 'n': 'none'}, None])

	def is_wifi_present(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-wifi-present')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 26, (), '', '?', args.execute, False, ['present'], [None])

	def set_wifi_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-configuration')

		parser.add_argument('ssid', type=create_string_checker(str, 32), help='string', metavar='<ssid>')
		parser.add_argument('connection', type=create_symbol_converter(ctx, convert_int, {'ad-hoc-static-ip': 5, 'access-point-dhcp': 2, 'ad-hoc-dhcp': 4, 'static-ip': 1, 'dhcp': 0, 'access-point-static-ip': 3}), help='int (dhcp: 0, static-ip: 1, access-point-dhcp: 2, access-point-static-ip: 3, ad-hoc-dhcp: 4, ad-hoc-static-ip: 5)', metavar='<connection>')
		parser.add_argument('ip', type=create_array_converter(ctx, convert_int, 4), help=get_array_type_name(ctx, 'int', 4), metavar='<ip>')
		parser.add_argument('subnet_mask', type=create_array_converter(ctx, convert_int, 4), help=get_array_type_name(ctx, 'int', 4), metavar='<subnet-mask>')
		parser.add_argument('gateway', type=create_array_converter(ctx, convert_int, 4), help=get_array_type_name(ctx, 'int', 4), metavar='<gateway>')
		parser.add_argument('port', type=convert_int, help='int', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 27, (args.ssid, args.connection, args.ip, args.subnet_mask, args.gateway, args.port), '32s B 4B 4B 4B H', '', None, args.expect_response, [], [])

	def get_wifi_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-configuration')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 28, (), '', '32s B 4B 4B 4B H', args.execute, False, ['ssid', 'connection', 'ip', 'subnet-mask', 'gateway', 'port'], [None, {0: 'dhcp', 1: 'static-ip', 2: 'access-point-dhcp', 3: 'access-point-static-ip', 4: 'ad-hoc-dhcp', 5: 'ad-hoc-static-ip'}, None, None, None, None])

	def set_wifi_encryption(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-encryption')

		parser.add_argument('encryption', type=create_symbol_converter(ctx, convert_int, {'wpa-enterprise': 1, 'wep': 2, 'wpa-wpa2': 0, 'no-encryption': 3}), help='int (wpa-wpa2: 0, wpa-enterprise: 1, wep: 2, no-encryption: 3)', metavar='<encryption>')
		parser.add_argument('key', type=create_string_checker(str, 50), help='string', metavar='<key>')
		parser.add_argument('key_index', type=convert_int, help='int', metavar='<key-index>')
		parser.add_argument('eap_options', type=create_symbol_converter(ctx, convert_int, {'outer-auth-eap-fast': 0, 'cert-type-private-key': 16, 'inner-auth-eap-mschap': 0, 'cert-type-client-cert': 8, 'outer-auth-eap-ttls': 2, 'outer-auth-eap-peap': 3, 'cert-type-ca-cert': 0, 'outer-auth-eap-tls': 1, 'inner-auth-eap-gtc': 4}), help='int (outer-auth-eap-fast: 0, outer-auth-eap-tls: 1, outer-auth-eap-ttls: 2, outer-auth-eap-peap: 3, inner-auth-eap-mschap: 0, inner-auth-eap-gtc: 4, cert-type-ca-cert: 0, cert-type-client-cert: 8, cert-type-private-key: 16)', metavar='<eap-options>')
		parser.add_argument('ca_certificate_length', type=convert_int, help='int', metavar='<ca-certificate-length>')
		parser.add_argument('client_certificate_length', type=convert_int, help='int', metavar='<client-certificate-length>')
		parser.add_argument('private_key_length', type=convert_int, help='int', metavar='<private-key-length>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 29, (args.encryption, args.key, args.key_index, args.eap_options, args.ca_certificate_length, args.client_certificate_length, args.private_key_length), 'B 50s B B H H H', '', None, args.expect_response, [], [])

	def get_wifi_encryption(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-encryption')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 30, (), '', 'B 50s B B H H H', args.execute, False, ['encryption', 'key', 'key-index', 'eap-options', 'ca-certificate-length', 'client-certificate-length', 'private-key-length'], [{0: 'wpa-wpa2', 1: 'wpa-enterprise', 2: 'wep', 3: 'no-encryption'}, None, None, {0: 'cert-type-ca-cert', 1: 'outer-auth-eap-tls', 2: 'outer-auth-eap-ttls', 3: 'outer-auth-eap-peap', 4: 'inner-auth-eap-gtc', 8: 'cert-type-client-cert', 16: 'cert-type-private-key'}, None, None, None])

	def get_wifi_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-status')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 31, (), '', '6B 6B B h 4B 4B 4B I I B', args.execute, False, ['mac-address', 'bssid', 'channel', 'rssi', 'ip', 'subnet-mask', 'gateway', 'rx-count', 'tx-count', 'state'], [None, None, None, None, None, None, None, None, None, {0: 'disassociated', 1: 'associated', 2: 'associating', 3: 'error', 255: 'not-initialized-yet'}])

	def refresh_wifi_status(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' refresh-wifi-status')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 32, (), '', '', None, args.expect_response, [], [])

	def set_wifi_certificate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-certificate')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, 32), help=get_array_type_name(ctx, 'int', 32), metavar='<data>')
		parser.add_argument('data_length', type=convert_int, help='int', metavar='<data-length>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 33, (args.index, args.data, args.data_length), 'H 32B B', '', None, args.expect_response, [], [])

	def get_wifi_certificate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-certificate')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 34, (args.index,), 'H', '32B B', args.execute, False, ['data', 'data-length'], [None, None])

	def set_wifi_power_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-power-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'low-power': 1, 'full-speed': 0}), help='int (full-speed: 0, low-power: 1)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 35, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_wifi_power_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-power-mode')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 36, (), '', 'B', args.execute, False, ['mode'], [{0: 'full-speed', 1: 'low-power'}])

	def get_wifi_buffer_info(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-buffer-info')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 37, (), '', 'I H H', args.execute, False, ['overflow', 'low-watermark', 'used'], [None, None, None])

	def set_wifi_regulatory_domain(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-regulatory-domain')

		parser.add_argument('domain', type=create_symbol_converter(ctx, convert_int, {'channel-1to14': 2, 'channel-1to13': 1, 'channel-1to11': 0}), help='int (channel-1to11: 0, channel-1to13: 1, channel-1to14: 2)', metavar='<domain>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 38, (args.domain,), 'B', '', None, args.expect_response, [], [])

	def get_wifi_regulatory_domain(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-regulatory-domain')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 39, (), '', 'B', args.execute, False, ['domain'], [{0: 'channel-1to11', 1: 'channel-1to13', 2: 'channel-1to14'}])

	def get_usb_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-usb-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 40, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_long_wifi_key(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-long-wifi-key')

		parser.add_argument('key', type=create_string_checker(str, 64), help='string', metavar='<key>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 41, (args.key,), '64s', '', None, args.expect_response, [], [])

	def get_long_wifi_key(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-long-wifi-key')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 42, (), '', '64s', args.execute, False, ['key'], [None])

	def set_wifi_hostname(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-hostname')

		parser.add_argument('hostname', type=create_string_checker(str, 16), help='string', metavar='<hostname>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 43, (args.hostname,), '16s', '', None, args.expect_response, [], [])

	def get_wifi_hostname(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-hostname')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 44, (), '', '16s', args.execute, False, ['hostname'], [None])

	def set_stack_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-stack-current-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 45, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_stack_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-current-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 46, (), '', 'I', args.execute, False, ['period'], [None])

	def set_stack_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-stack-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 47, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_stack_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-voltage-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 48, (), '', 'I', args.execute, False, ['period'], [None])

	def set_usb_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-usb-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 49, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_usb_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-usb-voltage-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 50, (), '', 'I', args.execute, False, ['period'], [None])

	def set_stack_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-stack-current-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 51, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_stack_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-current-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 52, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_stack_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-stack-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 53, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_stack_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 54, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_usb_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-usb-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 55, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_usb_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-usb-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 56, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 57, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 58, (), '', 'I', args.execute, False, ['debounce'], [None])

	def is_ethernet_present(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-ethernet-present')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 65, (), '', '?', args.execute, False, ['present'], [None])

	def set_ethernet_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-configuration')

		parser.add_argument('connection', type=create_symbol_converter(ctx, convert_int, {'dhcp': 0, 'static-ip': 1}), help='int (dhcp: 0, static-ip: 1)', metavar='<connection>')
		parser.add_argument('ip', type=create_array_converter(ctx, convert_int, 4), help=get_array_type_name(ctx, 'int', 4), metavar='<ip>')
		parser.add_argument('subnet_mask', type=create_array_converter(ctx, convert_int, 4), help=get_array_type_name(ctx, 'int', 4), metavar='<subnet-mask>')
		parser.add_argument('gateway', type=create_array_converter(ctx, convert_int, 4), help=get_array_type_name(ctx, 'int', 4), metavar='<gateway>')
		parser.add_argument('port', type=convert_int, help='int', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 66, (args.connection, args.ip, args.subnet_mask, args.gateway, args.port), 'B 4B 4B 4B H', '', None, args.expect_response, [], [])

	def get_ethernet_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ethernet-configuration')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 67, (), '', 'B 4B 4B 4B H', args.execute, False, ['connection', 'ip', 'subnet-mask', 'gateway', 'port'], [{0: 'dhcp', 1: 'static-ip'}, None, None, None, None])

	def get_ethernet_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ethernet-status')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 68, (), '', '6B 4B 4B 4B I I 32s', args.execute, False, ['mac-address', 'ip', 'subnet-mask', 'gateway', 'rx-count', 'tx-count', 'hostname'], [None, None, None, None, None, None, None])

	def set_ethernet_hostname(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-hostname')

		parser.add_argument('hostname', type=create_string_checker(str, 32), help='string', metavar='<hostname>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 69, (args.hostname,), '32s', '', None, args.expect_response, [], [])

	def set_ethernet_mac_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-mac-address')

		parser.add_argument('mac_address', type=create_array_converter(ctx, convert_int, 6), help=get_array_type_name(ctx, 'int', 6), metavar='<mac-address>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 70, (args.mac_address,), '6B', '', None, args.expect_response, [], [])

	def set_ethernet_websocket_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-websocket-configuration')

		parser.add_argument('sockets', type=convert_int, help='int', metavar='<sockets>')
		parser.add_argument('port', type=convert_int, help='int', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 71, (args.sockets, args.port), 'B H', '', None, args.expect_response, [], [])

	def get_ethernet_websocket_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ethernet-websocket-configuration')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 72, (), '', 'B H', args.execute, False, ['sockets', 'port'], [None, None])

	def set_ethernet_authentication_secret(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-authentication-secret')

		parser.add_argument('secret', type=create_string_checker(str, 64), help='string', metavar='<secret>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 73, (args.secret,), '64s', '', None, args.expect_response, [], [])

	def get_ethernet_authentication_secret(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ethernet-authentication-secret')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 74, (), '', '64s', args.execute, False, ['secret'], [None])

	def set_wifi_authentication_secret(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-authentication-secret')

		parser.add_argument('secret', type=create_string_checker(str, 64), help='string', metavar='<secret>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 75, (args.secret,), '64s', '', None, args.expect_response, [], [])

	def get_wifi_authentication_secret(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-authentication-secret')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 76, (), '', '64s', args.execute, False, ['secret'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_send_request(ctx, MasterBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MasterBrick, argv)

	functions = {
	'get-stack-voltage': get_stack_voltage,
	'get-stack-current': get_stack_current,
	'set-extension-type': set_extension_type,
	'get-extension-type': get_extension_type,
	'is-chibi-present': is_chibi_present,
	'set-chibi-address': set_chibi_address,
	'get-chibi-address': get_chibi_address,
	'set-chibi-master-address': set_chibi_master_address,
	'get-chibi-master-address': get_chibi_master_address,
	'set-chibi-slave-address': set_chibi_slave_address,
	'get-chibi-slave-address': get_chibi_slave_address,
	'get-chibi-signal-strength': get_chibi_signal_strength,
	'get-chibi-error-log': get_chibi_error_log,
	'set-chibi-frequency': set_chibi_frequency,
	'get-chibi-frequency': get_chibi_frequency,
	'set-chibi-channel': set_chibi_channel,
	'get-chibi-channel': get_chibi_channel,
	'is-rs485-present': is_rs485_present,
	'set-rs485-address': set_rs485_address,
	'get-rs485-address': get_rs485_address,
	'set-rs485-slave-address': set_rs485_slave_address,
	'get-rs485-slave-address': get_rs485_slave_address,
	'get-rs485-error-log': get_rs485_error_log,
	'set-rs485-configuration': set_rs485_configuration,
	'get-rs485-configuration': get_rs485_configuration,
	'is-wifi-present': is_wifi_present,
	'set-wifi-configuration': set_wifi_configuration,
	'get-wifi-configuration': get_wifi_configuration,
	'set-wifi-encryption': set_wifi_encryption,
	'get-wifi-encryption': get_wifi_encryption,
	'get-wifi-status': get_wifi_status,
	'refresh-wifi-status': refresh_wifi_status,
	'set-wifi-certificate': set_wifi_certificate,
	'get-wifi-certificate': get_wifi_certificate,
	'set-wifi-power-mode': set_wifi_power_mode,
	'get-wifi-power-mode': get_wifi_power_mode,
	'get-wifi-buffer-info': get_wifi_buffer_info,
	'set-wifi-regulatory-domain': set_wifi_regulatory_domain,
	'get-wifi-regulatory-domain': get_wifi_regulatory_domain,
	'get-usb-voltage': get_usb_voltage,
	'set-long-wifi-key': set_long_wifi_key,
	'get-long-wifi-key': get_long_wifi_key,
	'set-wifi-hostname': set_wifi_hostname,
	'get-wifi-hostname': get_wifi_hostname,
	'set-stack-current-callback-period': set_stack_current_callback_period,
	'get-stack-current-callback-period': get_stack_current_callback_period,
	'set-stack-voltage-callback-period': set_stack_voltage_callback_period,
	'get-stack-voltage-callback-period': get_stack_voltage_callback_period,
	'set-usb-voltage-callback-period': set_usb_voltage_callback_period,
	'get-usb-voltage-callback-period': get_usb_voltage_callback_period,
	'set-stack-current-callback-threshold': set_stack_current_callback_threshold,
	'get-stack-current-callback-threshold': get_stack_current_callback_threshold,
	'set-stack-voltage-callback-threshold': set_stack_voltage_callback_threshold,
	'get-stack-voltage-callback-threshold': get_stack_voltage_callback_threshold,
	'set-usb-voltage-callback-threshold': set_usb_voltage_callback_threshold,
	'get-usb-voltage-callback-threshold': get_usb_voltage_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'is-ethernet-present': is_ethernet_present,
	'set-ethernet-configuration': set_ethernet_configuration,
	'get-ethernet-configuration': get_ethernet_configuration,
	'get-ethernet-status': get_ethernet_status,
	'set-ethernet-hostname': set_ethernet_hostname,
	'set-ethernet-mac-address': set_ethernet_mac_address,
	'set-ethernet-websocket-configuration': set_ethernet_websocket_configuration,
	'get-ethernet-websocket-configuration': get_ethernet_websocket_configuration,
	'set-ethernet-authentication-secret': set_ethernet_authentication_secret,
	'get-ethernet-authentication-secret': get_ethernet_authentication_secret,
	'set-wifi-authentication-secret': set_wifi_authentication_secret,
	'get-wifi-authentication-secret': get_wifi_authentication_secret,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'master-brick', functions, argv)

def dispatch_master_brick(ctx, argv):
	prog_prefix = 'dispatch master-brick <uid>'

	def stack_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' stack-current')

		args = parser.parse_args(argv)

		device_callback(ctx, MasterBrick, 59, args.execute, ['current'])

	def stack_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' stack-voltage')

		args = parser.parse_args(argv)

		device_callback(ctx, MasterBrick, 60, args.execute, ['voltage'])

	def usb_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' usb-voltage')

		args = parser.parse_args(argv)

		device_callback(ctx, MasterBrick, 61, args.execute, ['voltage'])

	def stack_current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' stack-current-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, MasterBrick, 62, args.execute, ['current'])

	def stack_voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' stack-voltage-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, MasterBrick, 63, args.execute, ['voltage'])

	def usb_voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' usb-voltage-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, MasterBrick, 64, args.execute, ['voltage'])

	callbacks = {
	'stack-current': stack_current,
	'stack-voltage': stack_voltage,
	'usb-voltage': usb_voltage,
	'stack-current-reached': stack_current_reached,
	'stack-voltage-reached': stack_voltage_reached,
	'usb-voltage-reached': usb_voltage_reached
	}

	dispatch_generic(ctx, 'master-brick', callbacks, argv)

class MoistureBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[10] = 4; re[11] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'

def call_moisture_bricklet(ctx, argv):
	prog_prefix = 'call moisture-bricklet <uid>'

	def get_moisture_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moisture-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, MoistureBricklet, 1, (), '', 'H', args.execute, False, ['moisture'], [None])

	def set_moisture_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moisture-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MoistureBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_moisture_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moisture-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, MoistureBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_moisture_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moisture-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MoistureBricklet, 4, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_moisture_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moisture-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, MoistureBricklet, 5, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MoistureBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, MoistureBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MoistureBricklet, 10, (args.average,), 'B', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_send_request(ctx, MoistureBricklet, 11, (), '', 'B', args.execute, False, ['average'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MoistureBricklet, argv)

	functions = {
	'get-moisture-value': get_moisture_value,
	'set-moisture-callback-period': set_moisture_callback_period,
	'get-moisture-callback-period': get_moisture_callback_period,
	'set-moisture-callback-threshold': set_moisture_callback_threshold,
	'get-moisture-callback-threshold': get_moisture_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'get-identity': get_identity
	}

	call_generic(ctx, 'moisture-bricklet', functions, argv)

def dispatch_moisture_bricklet(ctx, argv):
	prog_prefix = 'dispatch moisture-bricklet <uid>'

	def moisture(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' moisture')

		args = parser.parse_args(argv)

		device_callback(ctx, MoistureBricklet, 8, args.execute, ['moisture'])

	def moisture_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' moisture-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, MoistureBricklet, 9, args.execute, ['moisture'])

	callbacks = {
	'moisture': moisture,
	'moisture-reached': moisture_reached
	}

	dispatch_generic(ctx, 'moisture-bricklet', callbacks, argv)

class MotionDetectorBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[255] = 1
		cf = self.callback_formats
		cf[2] = ''; cf[3] = ''

def call_motion_detector_bricklet(ctx, argv):
	prog_prefix = 'call motion-detector-bricklet <uid>'

	def get_motion_detected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motion-detected')

		args = parser.parse_args(argv)

		device_send_request(ctx, MotionDetectorBricklet, 1, (), '', 'B', args.execute, False, ['motion'], [{0: 'not-detected', 1: 'detected'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MotionDetectorBricklet, argv)

	functions = {
	'get-motion-detected': get_motion_detected,
	'get-identity': get_identity
	}

	call_generic(ctx, 'motion-detector-bricklet', functions, argv)

def dispatch_motion_detector_bricklet(ctx, argv):
	prog_prefix = 'dispatch motion-detector-bricklet <uid>'

	def motion_detected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' motion-detected')

		args = parser.parse_args(argv)

		device_callback(ctx, MotionDetectorBricklet, 2, args.execute, [])

	def detection_cycle_ended(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' detection-cycle-ended')

		args = parser.parse_args(argv)

		device_callback(ctx, MotionDetectorBricklet, 3, args.execute, [])

	callbacks = {
	'motion-detected': motion_detected,
	'detection-cycle-ended': detection_cycle_ended
	}

	dispatch_generic(ctx, 'motion-detector-bricklet', callbacks, argv)

class MultiTouchBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 4; re[3] = 4; re[4] = 1; re[6] = 4; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = 'H'

def call_multi_touch_bricklet(ctx, argv):
	prog_prefix = 'call multi-touch-bricklet <uid>'

	def get_touch_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-state')

		args = parser.parse_args(argv)

		device_send_request(ctx, MultiTouchBricklet, 1, (), '', 'H', args.execute, False, ['state'], [None])

	def recalibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' recalibrate')

		args = parser.parse_args(argv)

		device_send_request(ctx, MultiTouchBricklet, 2, (), '', '', None, args.expect_response, [], [])

	def set_electrode_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-electrode-config')

		parser.add_argument('enabled_electrodes', type=convert_int, help='int', metavar='<enabled-electrodes>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MultiTouchBricklet, 3, (args.enabled_electrodes,), 'H', '', None, args.expect_response, [], [])

	def get_electrode_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-electrode-config')

		args = parser.parse_args(argv)

		device_send_request(ctx, MultiTouchBricklet, 4, (), '', 'H', args.execute, False, ['enabled-electrodes'], [None])

	def set_electrode_sensitivity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-electrode-sensitivity')

		parser.add_argument('sensitivity', type=convert_int, help='int', metavar='<sensitivity>')

		args = parser.parse_args(argv)

		device_send_request(ctx, MultiTouchBricklet, 6, (args.sensitivity,), 'B', '', None, args.expect_response, [], [])

	def get_electrode_sensitivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-electrode-sensitivity')

		args = parser.parse_args(argv)

		device_send_request(ctx, MultiTouchBricklet, 7, (), '', 'B', args.execute, False, ['sensitivity'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MultiTouchBricklet, argv)

	functions = {
	'get-touch-state': get_touch_state,
	'recalibrate': recalibrate,
	'set-electrode-config': set_electrode_config,
	'get-electrode-config': get_electrode_config,
	'set-electrode-sensitivity': set_electrode_sensitivity,
	'get-electrode-sensitivity': get_electrode_sensitivity,
	'get-identity': get_identity
	}

	call_generic(ctx, 'multi-touch-bricklet', functions, argv)

def dispatch_multi_touch_bricklet(ctx, argv):
	prog_prefix = 'dispatch multi-touch-bricklet <uid>'

	def touch_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' touch-state')

		args = parser.parse_args(argv)

		device_callback(ctx, MultiTouchBricklet, 5, args.execute, ['state'])

	callbacks = {
	'touch-state': touch_state
	}

	dispatch_generic(ctx, 'multi-touch-bricklet', callbacks, argv)

class NFCRFIDBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 1; re[4] = 4; re[5] = 4; re[6] = 4; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'B ?'

def call_nfc_rfid_bricklet(ctx, argv):
	prog_prefix = 'call nfc-rfid-bricklet <uid>'

	def request_tag_id(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' request-tag-id')

		parser.add_argument('tag_type', type=create_symbol_converter(ctx, convert_int, {'mifare-classic': 0, 'type1': 1, 'type2': 2}), help='int (mifare-classic: 0, type1: 1, type2: 2)', metavar='<tag-type>')

		args = parser.parse_args(argv)

		device_send_request(ctx, NFCRFIDBricklet, 1, (args.tag_type,), 'B', '', None, args.expect_response, [], [])

	def get_tag_id(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-tag-id')

		args = parser.parse_args(argv)

		device_send_request(ctx, NFCRFIDBricklet, 2, (), '', 'B B 7B', args.execute, False, ['tag-type', 'tid-length', 'tid'], [{0: 'mifare-classic', 1: 'type1', 2: 'type2'}, None, None])

	def get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-state')

		args = parser.parse_args(argv)

		device_send_request(ctx, NFCRFIDBricklet, 3, (), '', 'B ?', args.execute, False, ['state', 'idle'], [{0: 'initialization', 128: 'idle', 2: 'request-tag-id', 3: 'authenticating-mifare-classic-page', 4: 'write-page', 5: 'request-page', 195: 'authenticating-mifare-classic-page-error', 194: 'request-tag-id-error', 197: 'request-page-error', 192: 'error', 130: 'request-tag-id-ready', 131: 'authenticating-mifare-classic-page-ready', 196: 'write-page-error', 132: 'write-page-ready', 133: 'request-page-ready'}, None])

	def authenticate_mifare_classic_page(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' authenticate-mifare-classic-page')

		parser.add_argument('page', type=convert_int, help='int', metavar='<page>')
		parser.add_argument('key_number', type=create_symbol_converter(ctx, convert_int, {'a': 0, 'b': 1}), help='int (a: 0, b: 1)', metavar='<key-number>')
		parser.add_argument('key', type=create_array_converter(ctx, convert_int, 6), help=get_array_type_name(ctx, 'int', 6), metavar='<key>')

		args = parser.parse_args(argv)

		device_send_request(ctx, NFCRFIDBricklet, 4, (args.page, args.key_number, args.key), 'H B 6B', '', None, args.expect_response, [], [])

	def write_page(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-page')

		parser.add_argument('page', type=convert_int, help='int', metavar='<page>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, 16), help=get_array_type_name(ctx, 'int', 16), metavar='<data>')

		args = parser.parse_args(argv)

		device_send_request(ctx, NFCRFIDBricklet, 5, (args.page, args.data), 'H 16B', '', None, args.expect_response, [], [])

	def request_page(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' request-page')

		parser.add_argument('page', type=convert_int, help='int', metavar='<page>')

		args = parser.parse_args(argv)

		device_send_request(ctx, NFCRFIDBricklet, 6, (args.page,), 'H', '', None, args.expect_response, [], [])

	def get_page(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-page')

		args = parser.parse_args(argv)

		device_send_request(ctx, NFCRFIDBricklet, 7, (), '', '16B', args.execute, False, ['data'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, NFCRFIDBricklet, argv)

	functions = {
	'request-tag-id': request_tag_id,
	'get-tag-id': get_tag_id,
	'get-state': get_state,
	'authenticate-mifare-classic-page': authenticate_mifare_classic_page,
	'write-page': write_page,
	'request-page': request_page,
	'get-page': get_page,
	'get-identity': get_identity
	}

	call_generic(ctx, 'nfc-rfid-bricklet', functions, argv)

def dispatch_nfc_rfid_bricklet(ctx, argv):
	prog_prefix = 'dispatch nfc-rfid-bricklet <uid>'

	def state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' state-changed')

		args = parser.parse_args(argv)

		device_callback(ctx, NFCRFIDBricklet, 8, args.execute, ['state', 'idle'])

	callbacks = {
	'state-changed': state_changed
	}

	dispatch_generic(ctx, 'nfc-rfid-bricklet', callbacks, argv)

class PiezoBuzzerBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 4; re[255] = 1
		cf = self.callback_formats
		cf[3] = ''; cf[4] = ''

def call_piezo_buzzer_bricklet(ctx, argv):
	prog_prefix = 'call piezo-buzzer-bricklet <uid>'

	def beep(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' beep')

		parser.add_argument('duration', type=convert_int, help='int', metavar='<duration>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PiezoBuzzerBricklet, 1, (args.duration,), 'I', '', None, args.expect_response, [], [])

	def morse_code(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' morse-code')

		parser.add_argument('morse', type=create_string_checker(str, 60), help='string', metavar='<morse>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PiezoBuzzerBricklet, 2, (args.morse,), '60s', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, PiezoBuzzerBricklet, argv)

	functions = {
	'beep': beep,
	'morse-code': morse_code,
	'get-identity': get_identity
	}

	call_generic(ctx, 'piezo-buzzer-bricklet', functions, argv)

def dispatch_piezo_buzzer_bricklet(ctx, argv):
	prog_prefix = 'dispatch piezo-buzzer-bricklet <uid>'

	def beep_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' beep-finished')

		args = parser.parse_args(argv)

		device_callback(ctx, PiezoBuzzerBricklet, 3, args.execute, [])

	def morse_code_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' morse-code-finished')

		args = parser.parse_args(argv)

		device_callback(ctx, PiezoBuzzerBricklet, 4, args.execute, [])

	callbacks = {
	'beep-finished': beep_finished,
	'morse-code-finished': morse_code_finished
	}

	dispatch_generic(ctx, 'piezo-buzzer-bricklet', callbacks, argv)

class PiezoSpeakerBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 4; re[3] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = ''; cf[5] = ''

def call_piezo_speaker_bricklet(ctx, argv):
	prog_prefix = 'call piezo-speaker-bricklet <uid>'

	def beep(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' beep')

		parser.add_argument('duration', type=create_symbol_converter(ctx, convert_int, {'infinite': 4294967295, 'off': 0}), help='int (off: 0, infinite: 4294967295)', metavar='<duration>')
		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PiezoSpeakerBricklet, 1, (args.duration, args.frequency), 'I H', '', None, args.expect_response, [], [])

	def morse_code(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' morse-code')

		parser.add_argument('morse', type=create_string_checker(str, 60), help='string', metavar='<morse>')
		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PiezoSpeakerBricklet, 2, (args.morse, args.frequency), '60s H', '', None, args.expect_response, [], [])

	def calibrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_send_request(ctx, PiezoSpeakerBricklet, 3, (), '', '?', args.execute, False, ['calibration'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, PiezoSpeakerBricklet, argv)

	functions = {
	'beep': beep,
	'morse-code': morse_code,
	'calibrate': calibrate,
	'get-identity': get_identity
	}

	call_generic(ctx, 'piezo-speaker-bricklet', functions, argv)

def dispatch_piezo_speaker_bricklet(ctx, argv):
	prog_prefix = 'dispatch piezo-speaker-bricklet <uid>'

	def beep_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' beep-finished')

		args = parser.parse_args(argv)

		device_callback(ctx, PiezoSpeakerBricklet, 4, args.execute, [])

	def morse_code_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' morse-code-finished')

		args = parser.parse_args(argv)

		device_callback(ctx, PiezoSpeakerBricklet, 5, args.execute, [])

	callbacks = {
	'beep-finished': beep_finished,
	'morse-code-finished': morse_code_finished
	}

	dispatch_generic(ctx, 'piezo-speaker-bricklet', callbacks, argv)

class PTCBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[17] = 4; re[18] = 1; re[19] = 1; re[20] = 4; re[21] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'i'; cf[14] = 'i'; cf[15] = 'H'; cf[16] = 'H'

def call_ptc_bricklet(ctx, argv):
	prog_prefix = 'call ptc-bricklet <uid>'

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 1, (), '', 'i', args.execute, False, ['temperature'], [None])

	def get_resistance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-resistance')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 2, (), '', 'H', args.execute, False, ['resistance'], [None])

	def set_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_resistance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-resistance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_resistance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-resistance-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 7, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 8, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_resistance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-resistance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_resistance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-resistance-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_noise_rejection_filter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-noise-rejection-filter')

		parser.add_argument('filter', type=create_symbol_converter(ctx, convert_int, {'50hz': 0, '60hz': 1}), help='int (50hz: 0, 60hz: 1)', metavar='<filter>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 17, (args.filter,), 'B', '', None, args.expect_response, [], [])

	def get_noise_rejection_filter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-noise-rejection-filter')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 18, (), '', 'B', args.execute, False, ['filter'], [{0: '50hz', 1: '60hz'}])

	def is_sensor_connected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-sensor-connected')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 19, (), '', '?', args.execute, False, ['connected'], [None])

	def set_wire_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wire-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'3': 3, '2': 2, '4': 4}), help='int (2: 2, 3: 3, 4: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 20, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_wire_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wire-mode')

		args = parser.parse_args(argv)

		device_send_request(ctx, PTCBricklet, 21, (), '', 'B', args.execute, False, ['mode'], [{2: '2', 3: '3', 4: '4'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, PTCBricklet, argv)

	functions = {
	'get-temperature': get_temperature,
	'get-resistance': get_resistance,
	'set-temperature-callback-period': set_temperature_callback_period,
	'get-temperature-callback-period': get_temperature_callback_period,
	'set-resistance-callback-period': set_resistance_callback_period,
	'get-resistance-callback-period': get_resistance_callback_period,
	'set-temperature-callback-threshold': set_temperature_callback_threshold,
	'get-temperature-callback-threshold': get_temperature_callback_threshold,
	'set-resistance-callback-threshold': set_resistance_callback_threshold,
	'get-resistance-callback-threshold': get_resistance_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-noise-rejection-filter': set_noise_rejection_filter,
	'get-noise-rejection-filter': get_noise_rejection_filter,
	'is-sensor-connected': is_sensor_connected,
	'set-wire-mode': set_wire_mode,
	'get-wire-mode': get_wire_mode,
	'get-identity': get_identity
	}

	call_generic(ctx, 'ptc-bricklet', functions, argv)

def dispatch_ptc_bricklet(ctx, argv):
	prog_prefix = 'dispatch ptc-bricklet <uid>'

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_callback(ctx, PTCBricklet, 13, args.execute, ['temperature'])

	def temperature_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, PTCBricklet, 14, args.execute, ['temperature'])

	def resistance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' resistance')

		args = parser.parse_args(argv)

		device_callback(ctx, PTCBricklet, 15, args.execute, ['resistance'])

	def resistance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' resistance-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, PTCBricklet, 16, args.execute, ['resistance'])

	callbacks = {
	'temperature': temperature,
	'temperature-reached': temperature_reached,
	'resistance': resistance,
	'resistance-reached': resistance_reached
	}

	dispatch_generic(ctx, 'ptc-bricklet', callbacks, argv)

class REDBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 1; re[6] = 4; re[7] = 1; re[8] = 1; re[9] = 1; re[10] = 1; re[11] = 1; re[12] = 1; re[13] = 1; re[14] = 1; re[15] = 1; re[16] = 1; re[17] = 1; re[18] = 1; re[19] = 1; re[20] = 1; re[21] = 4; re[22] = 1; re[23] = 1; re[24] = 4; re[25] = 4; re[26] = 1; re[27] = 1; re[28] = 1; re[29] = 1; re[33] = 1; re[34] = 1; re[35] = 1; re[36] = 1; re[37] = 1; re[38] = 1; re[39] = 1; re[40] = 1; re[41] = 1; re[42] = 1; re[43] = 1; re[44] = 1; re[46] = 1; re[47] = 1; re[48] = 1; re[49] = 1; re[50] = 1; re[51] = 1; re[52] = 1; re[53] = 1; re[54] = 1; re[55] = 1; re[56] = 1; re[57] = 1; re[58] = 1; re[59] = 1; re[60] = 1; re[61] = 1; re[62] = 1; re[63] = 1; re[64] = 1; re[255] = 1
		cf = self.callback_formats
		cf[30] = 'H B 60B B'; cf[31] = 'H B B'; cf[32] = 'H H'; cf[45] = 'H B Q B'; cf[65] = 'H'; cf[66] = 'H'

def call_red_brick(ctx, argv):
	prog_prefix = 'call red-brick <uid>'

	def create_session(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' create-session')

		parser.add_argument('lifetime', type=convert_int, help='int', metavar='<lifetime>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 1, (args.lifetime,), 'I', 'B H', args.execute, False, ['error-code', 'session-id'], [None, None])

	def expire_session(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' expire-session')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 2, (args.session_id,), 'H', 'B', args.execute, False, ['error-code'], [None])

	def expire_session_unchecked(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' expire-session-unchecked')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 3, (args.session_id,), 'H', '', None, args.expect_response, [], [])

	def keep_session_alive(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' keep-session-alive')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')
		parser.add_argument('lifetime', type=convert_int, help='int', metavar='<lifetime>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 4, (args.session_id, args.lifetime), 'H I', 'B', args.execute, False, ['error-code'], [None])

	def release_object(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' release-object')

		parser.add_argument('object_id', type=convert_int, help='int', metavar='<object-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 5, (args.object_id, args.session_id), 'H H', 'B', args.execute, False, ['error-code'], [None])

	def release_object_unchecked(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' release-object-unchecked')

		parser.add_argument('object_id', type=convert_int, help='int', metavar='<object-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 6, (args.object_id, args.session_id), 'H H', '', None, args.expect_response, [], [])

	def allocate_string(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' allocate-string')

		parser.add_argument('length_to_reserve', type=convert_int, help='int', metavar='<length-to-reserve>')
		parser.add_argument('buffer', type=create_string_checker(str, 58), help='string', metavar='<buffer>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 7, (args.length_to_reserve, args.buffer, args.session_id), 'I 58s H', 'B H', args.execute, False, ['error-code', 'string-id'], [None, None])

	def truncate_string(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' truncate-string')

		parser.add_argument('string_id', type=convert_int, help='int', metavar='<string-id>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 8, (args.string_id, args.length), 'H I', 'B', args.execute, False, ['error-code'], [None])

	def get_string_length(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-string-length')

		parser.add_argument('string_id', type=convert_int, help='int', metavar='<string-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 9, (args.string_id,), 'H', 'B I', args.execute, False, ['error-code', 'length'], [None, None])

	def set_string_chunk(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-string-chunk')

		parser.add_argument('string_id', type=convert_int, help='int', metavar='<string-id>')
		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')
		parser.add_argument('buffer', type=create_string_checker(str, 58), help='string', metavar='<buffer>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 10, (args.string_id, args.offset, args.buffer), 'H I 58s', 'B', args.execute, False, ['error-code'], [None])

	def get_string_chunk(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-string-chunk')

		parser.add_argument('string_id', type=convert_int, help='int', metavar='<string-id>')
		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 11, (args.string_id, args.offset), 'H I', 'B 63s', args.execute, False, ['error-code', 'buffer'], [None, None])

	def allocate_list(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' allocate-list')

		parser.add_argument('length_to_reserve', type=convert_int, help='int', metavar='<length-to-reserve>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 12, (args.length_to_reserve, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'list-id'], [None, None])

	def get_list_length(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-list-length')

		parser.add_argument('list_id', type=convert_int, help='int', metavar='<list-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 13, (args.list_id,), 'H', 'B H', args.execute, False, ['error-code', 'length'], [None, None])

	def get_list_item(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-list-item')

		parser.add_argument('list_id', type=convert_int, help='int', metavar='<list-id>')
		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 14, (args.list_id, args.index, args.session_id), 'H H H', 'B H B', args.execute, False, ['error-code', 'item-object-id', 'type'], [None, None, {0: 'string', 1: 'list', 2: 'file', 3: 'directory', 4: 'process', 5: 'program'}])

	def append_to_list(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' append-to-list')

		parser.add_argument('list_id', type=convert_int, help='int', metavar='<list-id>')
		parser.add_argument('item_object_id', type=convert_int, help='int', metavar='<item-object-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 15, (args.list_id, args.item_object_id), 'H H', 'B', args.execute, False, ['error-code'], [None])

	def remove_from_list(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' remove-from-list')

		parser.add_argument('list_id', type=convert_int, help='int', metavar='<list-id>')
		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 16, (args.list_id, args.index), 'H H', 'B', args.execute, False, ['error-code'], [None])

	def open_file(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' open-file')

		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('flags', type=create_symbol_converter(ctx, convert_int, {'exclusive': 32, 'temporary': 256, 'truncate': 128, 'create': 16, 'replace': 512, 'read-write': 4, 'read-only': 1, 'write-only': 2, 'append': 8, 'non-blocking': 64}), help='int (read-only: 1, write-only: 2, read-write: 4, append: 8, create: 16, exclusive: 32, non-blocking: 64, truncate: 128, temporary: 256, replace: 512)', metavar='<flags>')
		parser.add_argument('permissions', type=create_symbol_converter(ctx, convert_int, {'group-all': 56, 'group-write': 16, 'others-write': 2, 'others-read': 4, 'user-write': 128, 'group-execute': 8, 'user-read': 256, 'others-all': 7, 'user-all': 448, 'group-read': 32, 'others-execute': 1, 'user-execute': 64}), help='int (user-all: 448, user-read: 256, user-write: 128, user-execute: 64, group-all: 56, group-read: 32, group-write: 16, group-execute: 8, others-all: 7, others-read: 4, others-write: 2, others-execute: 1)', metavar='<permissions>')
		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')
		parser.add_argument('gid', type=convert_int, help='int', metavar='<gid>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 17, (args.name_string_id, args.flags, args.permissions, args.uid, args.gid, args.session_id), 'H I H I I H', 'B H', args.execute, False, ['error-code', 'file-id'], [None, None])

	def create_pipe(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' create-pipe')

		parser.add_argument('flags', type=create_symbol_converter(ctx, convert_int, {'non-blocking-read': 1, 'non-blocking-write': 2}), help='int (non-blocking-read: 1, non-blocking-write: 2)', metavar='<flags>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 18, (args.flags, args.length, args.session_id), 'I Q H', 'B H', args.execute, False, ['error-code', 'file-id'], [None, None])

	def get_file_info(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-file-info')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 19, (args.file_id, args.session_id), 'H H', 'B B H I H I I Q Q Q Q', args.execute, False, ['error-code', 'type', 'name-string-id', 'flags', 'permissions', 'uid', 'gid', 'length', 'access-timestamp', 'modification-timestamp', 'status-change-timestamp'], [None, {0: 'unknown', 1: 'regular', 2: 'directory', 3: 'character', 4: 'block', 5: 'fifo', 6: 'symlink', 7: 'socket', 8: 'pipe'}, None, None, {448: 'user-all', 256: 'user-read', 2: 'others-write', 4: 'others-read', 32: 'group-read', 64: 'user-execute', 128: 'user-write', 7: 'others-all', 16: 'group-write', 8: 'group-execute', 1: 'others-execute', 56: 'group-all'}, None, None, None, None, None, None])

	def read_file(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-file')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('length_to_read', type=convert_int, help='int', metavar='<length-to-read>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 20, (args.file_id, args.length_to_read), 'H B', 'B 62B B', args.execute, False, ['error-code', 'buffer', 'length-read'], [None, None, None])

	def read_file_async(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' read-file-async')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('length_to_read', type=convert_int, help='int', metavar='<length-to-read>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 21, (args.file_id, args.length_to_read), 'H Q', '', None, args.expect_response, [], [])

	def abort_async_file_read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' abort-async-file-read')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 22, (args.file_id,), 'H', 'B', args.execute, False, ['error-code'], [None])

	def write_file(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-file')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('buffer', type=create_array_converter(ctx, convert_int, 61), help=get_array_type_name(ctx, 'int', 61), metavar='<buffer>')
		parser.add_argument('length_to_write', type=convert_int, help='int', metavar='<length-to-write>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 23, (args.file_id, args.buffer, args.length_to_write), 'H 61B B', 'B B', args.execute, False, ['error-code', 'length-written'], [None, None])

	def write_file_unchecked(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-file-unchecked')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('buffer', type=create_array_converter(ctx, convert_int, 61), help=get_array_type_name(ctx, 'int', 61), metavar='<buffer>')
		parser.add_argument('length_to_write', type=convert_int, help='int', metavar='<length-to-write>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 24, (args.file_id, args.buffer, args.length_to_write), 'H 61B B', '', None, args.expect_response, [], [])

	def write_file_async(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-file-async')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('buffer', type=create_array_converter(ctx, convert_int, 61), help=get_array_type_name(ctx, 'int', 61), metavar='<buffer>')
		parser.add_argument('length_to_write', type=convert_int, help='int', metavar='<length-to-write>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 25, (args.file_id, args.buffer, args.length_to_write), 'H 61B B', '', None, args.expect_response, [], [])

	def set_file_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-file-position')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')
		parser.add_argument('origin', type=create_symbol_converter(ctx, convert_int, {'current': 1, 'end': 2, 'beginning': 0}), help='int (beginning: 0, current: 1, end: 2)', metavar='<origin>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 26, (args.file_id, args.offset, args.origin), 'H q B', 'B Q', args.execute, False, ['error-code', 'position'], [None, None])

	def get_file_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-file-position')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 27, (args.file_id,), 'H', 'B Q', args.execute, False, ['error-code', 'position'], [None, None])

	def set_file_events(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-file-events')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('events', type=create_symbol_converter(ctx, convert_int, {'writable': 2, 'readable': 1}), help='int (readable: 1, writable: 2)', metavar='<events>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 28, (args.file_id, args.events), 'H H', 'B', args.execute, False, ['error-code'], [None])

	def get_file_events(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-file-events')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 29, (args.file_id,), 'H', 'B H', args.execute, False, ['error-code', 'events'], [None, {1: 'readable', 2: 'writable'}])

	def open_directory(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' open-directory')

		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 33, (args.name_string_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'directory-id'], [None, None])

	def get_directory_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-directory-name')

		parser.add_argument('directory_id', type=convert_int, help='int', metavar='<directory-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 34, (args.directory_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'name-string-id'], [None, None])

	def get_next_directory_entry(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-next-directory-entry')

		parser.add_argument('directory_id', type=convert_int, help='int', metavar='<directory-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 35, (args.directory_id, args.session_id), 'H H', 'B H B', args.execute, False, ['error-code', 'name-string-id', 'type'], [None, None, {0: 'unknown', 1: 'regular', 2: 'directory', 3: 'character', 4: 'block', 5: 'fifo', 6: 'symlink', 7: 'socket'}])

	def rewind_directory(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' rewind-directory')

		parser.add_argument('directory_id', type=convert_int, help='int', metavar='<directory-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 36, (args.directory_id,), 'H', 'B', args.execute, False, ['error-code'], [None])

	def create_directory(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' create-directory')

		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('flags', type=create_symbol_converter(ctx, convert_int, {'exclusive': 2, 'recursive': 1}), help='int (recursive: 1, exclusive: 2)', metavar='<flags>')
		parser.add_argument('permissions', type=create_symbol_converter(ctx, convert_int, {'group-all': 56, 'group-write': 16, 'others-write': 2, 'others-read': 4, 'user-write': 128, 'group-execute': 8, 'user-read': 256, 'others-all': 7, 'user-all': 448, 'group-read': 32, 'others-execute': 1, 'user-execute': 64}), help='int (user-all: 448, user-read: 256, user-write: 128, user-execute: 64, group-all: 56, group-read: 32, group-write: 16, group-execute: 8, others-all: 7, others-read: 4, others-write: 2, others-execute: 1)', metavar='<permissions>')
		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')
		parser.add_argument('gid', type=convert_int, help='int', metavar='<gid>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 37, (args.name_string_id, args.flags, args.permissions, args.uid, args.gid), 'H I H I I', 'B', args.execute, False, ['error-code'], [None])

	def get_processes(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-processes')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 38, (args.session_id,), 'H', 'B H', args.execute, False, ['error-code', 'processes-list-id'], [None, None])

	def spawn_process(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' spawn-process')

		parser.add_argument('executable_string_id', type=convert_int, help='int', metavar='<executable-string-id>')
		parser.add_argument('arguments_list_id', type=convert_int, help='int', metavar='<arguments-list-id>')
		parser.add_argument('environment_list_id', type=convert_int, help='int', metavar='<environment-list-id>')
		parser.add_argument('working_directory_string_id', type=convert_int, help='int', metavar='<working-directory-string-id>')
		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')
		parser.add_argument('gid', type=convert_int, help='int', metavar='<gid>')
		parser.add_argument('stdin_file_id', type=convert_int, help='int', metavar='<stdin-file-id>')
		parser.add_argument('stdout_file_id', type=convert_int, help='int', metavar='<stdout-file-id>')
		parser.add_argument('stderr_file_id', type=convert_int, help='int', metavar='<stderr-file-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 39, (args.executable_string_id, args.arguments_list_id, args.environment_list_id, args.working_directory_string_id, args.uid, args.gid, args.stdin_file_id, args.stdout_file_id, args.stderr_file_id, args.session_id), 'H H H H I I H H H H', 'B H', args.execute, False, ['error-code', 'process-id'], [None, None])

	def kill_process(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' kill-process')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')
		parser.add_argument('signal', type=create_symbol_converter(ctx, convert_int, {'quit': 3, 'user2': 12, 'continue': 18, 'user1': 10, 'stop': 19, 'terminate': 15, 'abort': 6, 'kill': 9, 'interrupt': 2}), help='int (interrupt: 2, quit: 3, abort: 6, kill: 9, user1: 10, user2: 12, terminate: 15, continue: 18, stop: 19)', metavar='<signal>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 40, (args.process_id, args.signal), 'H B', 'B', args.execute, False, ['error-code'], [None])

	def get_process_command(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-process-command')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 41, (args.process_id, args.session_id), 'H H', 'B H H H H', args.execute, False, ['error-code', 'executable-string-id', 'arguments-list-id', 'environment-list-id', 'working-directory-string-id'], [None, None, None, None, None])

	def get_process_identity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-process-identity')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 42, (args.process_id,), 'H', 'B I I I', args.execute, False, ['error-code', 'pid', 'uid', 'gid'], [None, None, None, None])

	def get_process_stdio(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-process-stdio')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 43, (args.process_id, args.session_id), 'H H', 'B H H H', args.execute, False, ['error-code', 'stdin-file-id', 'stdout-file-id', 'stderr-file-id'], [None, None, None, None])

	def get_process_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-process-state')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 44, (args.process_id,), 'H', 'B B Q B', args.execute, False, ['error-code', 'state', 'timestamp', 'exit-code'], [None, {0: 'unknown', 1: 'running', 2: 'error', 3: 'exited', 4: 'killed', 5: 'stopped'}, None, None])

	def get_programs(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-programs')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 46, (args.session_id,), 'H', 'B H', args.execute, False, ['error-code', 'programs-list-id'], [None, None])

	def define_program(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' define-program')

		parser.add_argument('identifier_string_id', type=convert_int, help='int', metavar='<identifier-string-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 47, (args.identifier_string_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'program-id'], [None, None])

	def purge_program(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' purge-program')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('cookie', type=convert_int, help='int', metavar='<cookie>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 48, (args.program_id, args.cookie), 'H I', 'B', args.execute, False, ['error-code'], [None])

	def get_program_identifier(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-identifier')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 49, (args.program_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'identifier-string-id'], [None, None])

	def get_program_root_directory(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-root-directory')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 50, (args.program_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'root-directory-string-id'], [None, None])

	def set_program_command(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-program-command')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('executable_string_id', type=convert_int, help='int', metavar='<executable-string-id>')
		parser.add_argument('arguments_list_id', type=convert_int, help='int', metavar='<arguments-list-id>')
		parser.add_argument('environment_list_id', type=convert_int, help='int', metavar='<environment-list-id>')
		parser.add_argument('working_directory_string_id', type=convert_int, help='int', metavar='<working-directory-string-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 51, (args.program_id, args.executable_string_id, args.arguments_list_id, args.environment_list_id, args.working_directory_string_id), 'H H H H H', 'B', args.execute, False, ['error-code'], [None])

	def get_program_command(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-command')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 52, (args.program_id, args.session_id), 'H H', 'B H H H H', args.execute, False, ['error-code', 'executable-string-id', 'arguments-list-id', 'environment-list-id', 'working-directory-string-id'], [None, None, None, None, None])

	def set_program_stdio_redirection(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-program-stdio-redirection')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('stdin_redirection', type=create_symbol_converter(ctx, convert_int, {'individual-log': 3, 'stdout': 5, 'dev-null': 0, 'pipe': 1, 'file': 2, 'continuous-log': 4}), help='int (dev-null: 0, pipe: 1, file: 2, individual-log: 3, continuous-log: 4, stdout: 5)', metavar='<stdin-redirection>')
		parser.add_argument('stdin_file_name_string_id', type=convert_int, help='int', metavar='<stdin-file-name-string-id>')
		parser.add_argument('stdout_redirection', type=create_symbol_converter(ctx, convert_int, {'individual-log': 3, 'stdout': 5, 'dev-null': 0, 'pipe': 1, 'file': 2, 'continuous-log': 4}), help='int (dev-null: 0, pipe: 1, file: 2, individual-log: 3, continuous-log: 4, stdout: 5)', metavar='<stdout-redirection>')
		parser.add_argument('stdout_file_name_string_id', type=convert_int, help='int', metavar='<stdout-file-name-string-id>')
		parser.add_argument('stderr_redirection', type=create_symbol_converter(ctx, convert_int, {'individual-log': 3, 'stdout': 5, 'dev-null': 0, 'pipe': 1, 'file': 2, 'continuous-log': 4}), help='int (dev-null: 0, pipe: 1, file: 2, individual-log: 3, continuous-log: 4, stdout: 5)', metavar='<stderr-redirection>')
		parser.add_argument('stderr_file_name_string_id', type=convert_int, help='int', metavar='<stderr-file-name-string-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 53, (args.program_id, args.stdin_redirection, args.stdin_file_name_string_id, args.stdout_redirection, args.stdout_file_name_string_id, args.stderr_redirection, args.stderr_file_name_string_id), 'H B H B H B H', 'B', args.execute, False, ['error-code'], [None])

	def get_program_stdio_redirection(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-stdio-redirection')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 54, (args.program_id, args.session_id), 'H H', 'B B H B H B H', args.execute, False, ['error-code', 'stdin-redirection', 'stdin-file-name-string-id', 'stdout-redirection', 'stdout-file-name-string-id', 'stderr-redirection', 'stderr-file-name-string-id'], [None, {0: 'dev-null', 1: 'pipe', 2: 'file', 3: 'individual-log', 4: 'continuous-log', 5: 'stdout'}, None, {0: 'dev-null', 1: 'pipe', 2: 'file', 3: 'individual-log', 4: 'continuous-log', 5: 'stdout'}, None, {0: 'dev-null', 1: 'pipe', 2: 'file', 3: 'individual-log', 4: 'continuous-log', 5: 'stdout'}, None])

	def set_program_schedule(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-program-schedule')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('start_mode', type=create_symbol_converter(ctx, convert_int, {'cron': 3, 'always': 1, 'never': 0, 'interval': 2}), help='int (never: 0, always: 1, interval: 2, cron: 3)', metavar='<start-mode>')
		parser.add_argument('continue_after_error', type=convert_bool, help='bool', metavar='<continue-after-error>')
		parser.add_argument('start_interval', type=convert_int, help='int', metavar='<start-interval>')
		parser.add_argument('start_fields_string_id', type=convert_int, help='int', metavar='<start-fields-string-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 55, (args.program_id, args.start_mode, args.continue_after_error, args.start_interval, args.start_fields_string_id), 'H B ? I H', 'B', args.execute, False, ['error-code'], [None])

	def get_program_schedule(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-schedule')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 56, (args.program_id, args.session_id), 'H H', 'B B ? I H', args.execute, False, ['error-code', 'start-mode', 'continue-after-error', 'start-interval', 'start-fields-string-id'], [None, {0: 'never', 1: 'always', 2: 'interval', 3: 'cron'}, None, None, None])

	def get_program_scheduler_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-scheduler-state')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 57, (args.program_id, args.session_id), 'H H', 'B B Q H', args.execute, False, ['error-code', 'state', 'timestamp', 'message-string-id'], [None, {0: 'stopped', 1: 'running'}, None, None])

	def continue_program_schedule(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' continue-program-schedule')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 58, (args.program_id,), 'H', 'B', args.execute, False, ['error-code'], [None])

	def start_program(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' start-program')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 59, (args.program_id,), 'H', 'B', args.execute, False, ['error-code'], [None])

	def get_last_spawned_program_process(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-last-spawned-program-process')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 60, (args.program_id, args.session_id), 'H H', 'B H Q', args.execute, False, ['error-code', 'process-id', 'timestamp'], [None, None, None])

	def get_custom_program_option_names(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-custom-program-option-names')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 61, (args.program_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'names-list-id'], [None, None])

	def set_custom_program_option_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-custom-program-option-value')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('value_string_id', type=convert_int, help='int', metavar='<value-string-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 62, (args.program_id, args.name_string_id, args.value_string_id), 'H H H', 'B', args.execute, False, ['error-code'], [None])

	def get_custom_program_option_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-custom-program-option-value')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 63, (args.program_id, args.name_string_id, args.session_id), 'H H H', 'B H', args.execute, False, ['error-code', 'value-string-id'], [None, None])

	def remove_custom_program_option(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' remove-custom-program-option')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')

		args = parser.parse_args(argv)

		device_send_request(ctx, REDBrick, 64, (args.program_id, args.name_string_id), 'H H', 'B', args.execute, False, ['error-code'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, REDBrick, argv)

	functions = {
	'create-session': create_session,
	'expire-session': expire_session,
	'expire-session-unchecked': expire_session_unchecked,
	'keep-session-alive': keep_session_alive,
	'release-object': release_object,
	'release-object-unchecked': release_object_unchecked,
	'allocate-string': allocate_string,
	'truncate-string': truncate_string,
	'get-string-length': get_string_length,
	'set-string-chunk': set_string_chunk,
	'get-string-chunk': get_string_chunk,
	'allocate-list': allocate_list,
	'get-list-length': get_list_length,
	'get-list-item': get_list_item,
	'append-to-list': append_to_list,
	'remove-from-list': remove_from_list,
	'open-file': open_file,
	'create-pipe': create_pipe,
	'get-file-info': get_file_info,
	'read-file': read_file,
	'read-file-async': read_file_async,
	'abort-async-file-read': abort_async_file_read,
	'write-file': write_file,
	'write-file-unchecked': write_file_unchecked,
	'write-file-async': write_file_async,
	'set-file-position': set_file_position,
	'get-file-position': get_file_position,
	'set-file-events': set_file_events,
	'get-file-events': get_file_events,
	'open-directory': open_directory,
	'get-directory-name': get_directory_name,
	'get-next-directory-entry': get_next_directory_entry,
	'rewind-directory': rewind_directory,
	'create-directory': create_directory,
	'get-processes': get_processes,
	'spawn-process': spawn_process,
	'kill-process': kill_process,
	'get-process-command': get_process_command,
	'get-process-identity': get_process_identity,
	'get-process-stdio': get_process_stdio,
	'get-process-state': get_process_state,
	'get-programs': get_programs,
	'define-program': define_program,
	'purge-program': purge_program,
	'get-program-identifier': get_program_identifier,
	'get-program-root-directory': get_program_root_directory,
	'set-program-command': set_program_command,
	'get-program-command': get_program_command,
	'set-program-stdio-redirection': set_program_stdio_redirection,
	'get-program-stdio-redirection': get_program_stdio_redirection,
	'set-program-schedule': set_program_schedule,
	'get-program-schedule': get_program_schedule,
	'get-program-scheduler-state': get_program_scheduler_state,
	'continue-program-schedule': continue_program_schedule,
	'start-program': start_program,
	'get-last-spawned-program-process': get_last_spawned_program_process,
	'get-custom-program-option-names': get_custom_program_option_names,
	'set-custom-program-option-value': set_custom_program_option_value,
	'get-custom-program-option-value': get_custom_program_option_value,
	'remove-custom-program-option': remove_custom_program_option,
	'get-identity': get_identity
	}

	call_generic(ctx, 'red-brick', functions, argv)

def dispatch_red_brick(ctx, argv):
	prog_prefix = 'dispatch red-brick <uid>'

	def async_file_read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' async-file-read')

		args = parser.parse_args(argv)

		device_callback(ctx, REDBrick, 30, args.execute, ['file-id', 'error-code', 'buffer', 'length-read'])

	def async_file_write(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' async-file-write')

		args = parser.parse_args(argv)

		device_callback(ctx, REDBrick, 31, args.execute, ['file-id', 'error-code', 'length-written'])

	def file_events_occurred(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' file-events-occurred')

		args = parser.parse_args(argv)

		device_callback(ctx, REDBrick, 32, args.execute, ['file-id', 'events'])

	def process_state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' process-state-changed')

		args = parser.parse_args(argv)

		device_callback(ctx, REDBrick, 45, args.execute, ['process-id', 'state', 'timestamp', 'exit-code'])

	def program_scheduler_state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' program-scheduler-state-changed')

		args = parser.parse_args(argv)

		device_callback(ctx, REDBrick, 65, args.execute, ['program-id'])

	def program_process_spawned(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' program-process-spawned')

		args = parser.parse_args(argv)

		device_callback(ctx, REDBrick, 66, args.execute, ['program-id'])

	callbacks = {
	'async-file-read': async_file_read,
	'async-file-write': async_file_write,
	'file-events-occurred': file_events_occurred,
	'process-state-changed': process_state_changed,
	'program-scheduler-state-changed': program_scheduler_state_changed,
	'program-process-spawned': program_process_spawned
	}

	dispatch_generic(ctx, 'red-brick', callbacks, argv)

class RemoteSwitchBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[4] = 4; re[5] = 1; re[6] = 4; re[7] = 4; re[8] = 4; re[9] = 4; re[255] = 1
		cf = self.callback_formats
		cf[3] = ''

def call_remote_switch_bricklet(ctx, argv):
	prog_prefix = 'call remote-switch-bricklet <uid>'

	def switch_socket(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket')

		parser.add_argument('house_code', type=convert_int, help='int', metavar='<house-code>')
		parser.add_argument('receiver_code', type=convert_int, help='int', metavar='<receiver-code>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'on': 1, 'off': 0}), help='int (off: 0, on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RemoteSwitchBricklet, 1, (args.house_code, args.receiver_code, args.switch_to), 'B B B', '', None, args.expect_response, [], [])

	def get_switching_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-switching-state')

		args = parser.parse_args(argv)

		device_send_request(ctx, RemoteSwitchBricklet, 2, (), '', 'B', args.execute, False, ['state'], [{0: 'ready', 1: 'busy'}])

	def set_repeats(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-repeats')

		parser.add_argument('repeats', type=convert_int, help='int', metavar='<repeats>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RemoteSwitchBricklet, 4, (args.repeats,), 'B', '', None, args.expect_response, [], [])

	def get_repeats(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-repeats')

		args = parser.parse_args(argv)

		device_send_request(ctx, RemoteSwitchBricklet, 5, (), '', 'B', args.execute, False, ['repeats'], [None])

	def switch_socket_a(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket-a')

		parser.add_argument('house_code', type=convert_int, help='int', metavar='<house-code>')
		parser.add_argument('receiver_code', type=convert_int, help='int', metavar='<receiver-code>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'on': 1, 'off': 0}), help='int (off: 0, on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RemoteSwitchBricklet, 6, (args.house_code, args.receiver_code, args.switch_to), 'B B B', '', None, args.expect_response, [], [])

	def switch_socket_b(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket-b')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')
		parser.add_argument('unit', type=convert_int, help='int', metavar='<unit>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'on': 1, 'off': 0}), help='int (off: 0, on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RemoteSwitchBricklet, 7, (args.address, args.unit, args.switch_to), 'I B B', '', None, args.expect_response, [], [])

	def dim_socket_b(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' dim-socket-b')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')
		parser.add_argument('unit', type=convert_int, help='int', metavar='<unit>')
		parser.add_argument('dim_value', type=convert_int, help='int', metavar='<dim-value>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RemoteSwitchBricklet, 8, (args.address, args.unit, args.dim_value), 'I B B', '', None, args.expect_response, [], [])

	def switch_socket_c(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket-c')

		parser.add_argument('system_code', type=check_char, help='char', metavar='<system-code>')
		parser.add_argument('device_code', type=convert_int, help='int', metavar='<device-code>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'on': 1, 'off': 0}), help='int (off: 0, on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RemoteSwitchBricklet, 9, (args.system_code, args.device_code, args.switch_to), 'c B B', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RemoteSwitchBricklet, argv)

	functions = {
	'switch-socket': switch_socket,
	'get-switching-state': get_switching_state,
	'set-repeats': set_repeats,
	'get-repeats': get_repeats,
	'switch-socket-a': switch_socket_a,
	'switch-socket-b': switch_socket_b,
	'dim-socket-b': dim_socket_b,
	'switch-socket-c': switch_socket_c,
	'get-identity': get_identity
	}

	call_generic(ctx, 'remote-switch-bricklet', functions, argv)

def dispatch_remote_switch_bricklet(ctx, argv):
	prog_prefix = 'dispatch remote-switch-bricklet <uid>'

	def switching_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' switching-done')

		args = parser.parse_args(argv)

		device_callback(ctx, RemoteSwitchBricklet, 3, args.execute, [])

	callbacks = {
	'switching-done': switching_done
	}

	dispatch_generic(ctx, 'remote-switch-bricklet', callbacks, argv)

class RotaryEncoderBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[10] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'i'; cf[9] = 'i'; cf[11] = ''; cf[12] = ''

def call_rotary_encoder_bricklet(ctx, argv):
	prog_prefix = 'call rotary-encoder-bricklet <uid>'

	def get_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count')

		parser.add_argument('reset', type=convert_bool, help='bool', metavar='<reset>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryEncoderBricklet, 1, (args.reset,), '?', 'i', args.execute, False, ['count'], [None])

	def set_count_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-count-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryEncoderBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_count_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryEncoderBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_count_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-count-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryEncoderBricklet, 4, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_count_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryEncoderBricklet, 5, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryEncoderBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryEncoderBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def is_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-pressed')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryEncoderBricklet, 10, (), '', '?', args.execute, False, ['pressed'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RotaryEncoderBricklet, argv)

	functions = {
	'get-count': get_count,
	'set-count-callback-period': set_count_callback_period,
	'get-count-callback-period': get_count_callback_period,
	'set-count-callback-threshold': set_count_callback_threshold,
	'get-count-callback-threshold': get_count_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'is-pressed': is_pressed,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rotary-encoder-bricklet', functions, argv)

def dispatch_rotary_encoder_bricklet(ctx, argv):
	prog_prefix = 'dispatch rotary-encoder-bricklet <uid>'

	def count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' count')

		args = parser.parse_args(argv)

		device_callback(ctx, RotaryEncoderBricklet, 8, args.execute, ['count'])

	def count_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' count-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, RotaryEncoderBricklet, 9, args.execute, ['count'])

	def pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' pressed')

		args = parser.parse_args(argv)

		device_callback(ctx, RotaryEncoderBricklet, 11, args.execute, [])

	def released(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' released')

		args = parser.parse_args(argv)

		device_callback(ctx, RotaryEncoderBricklet, 12, args.execute, [])

	callbacks = {
	'count': count,
	'count-reached': count_reached,
	'pressed': pressed,
	'released': released
	}

	dispatch_generic(ctx, 'rotary-encoder-bricklet', callbacks, argv)

class RotaryPotiBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'h'; cf[14] = 'H'; cf[15] = 'h'; cf[16] = 'H'

def call_rotary_poti_bricklet(ctx, argv):
	prog_prefix = 'call rotary-poti-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 1, (), '', 'h', args.execute, False, ['position'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_position_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_position_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_position_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 7, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_position_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 8, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, RotaryPotiBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RotaryPotiBricklet, argv)

	functions = {
	'get-position': get_position,
	'get-analog-value': get_analog_value,
	'set-position-callback-period': set_position_callback_period,
	'get-position-callback-period': get_position_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-position-callback-threshold': set_position_callback_threshold,
	'get-position-callback-threshold': get_position_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rotary-poti-bricklet', functions, argv)

def dispatch_rotary_poti_bricklet(ctx, argv):
	prog_prefix = 'dispatch rotary-poti-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_callback(ctx, RotaryPotiBricklet, 13, args.execute, ['position'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, RotaryPotiBricklet, 14, args.execute, ['value'])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, RotaryPotiBricklet, 15, args.execute, ['position'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, RotaryPotiBricklet, 16, args.execute, ['value'])

	callbacks = {
	'position': position,
	'analog-value': analog_value,
	'position-reached': position_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'rotary-poti-bricklet', callbacks, argv)

class SegmentDisplay4x7Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 4; re[4] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = ''

def call_segment_display_4x7_bricklet(ctx, argv):
	prog_prefix = 'call segment-display-4x7-bricklet <uid>'

	def set_segments(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-segments')

		parser.add_argument('segments', type=create_array_converter(ctx, convert_int, 4), help=get_array_type_name(ctx, 'int', 4), metavar='<segments>')
		parser.add_argument('brightness', type=convert_int, help='int', metavar='<brightness>')
		parser.add_argument('colon', type=convert_bool, help='bool', metavar='<colon>')

		args = parser.parse_args(argv)

		device_send_request(ctx, SegmentDisplay4x7Bricklet, 1, (args.segments, args.brightness, args.colon), '4B B ?', '', None, args.expect_response, [], [])

	def get_segments(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-segments')

		args = parser.parse_args(argv)

		device_send_request(ctx, SegmentDisplay4x7Bricklet, 2, (), '', '4B B ?', args.execute, False, ['segments', 'brightness', 'colon'], [None, None, None])

	def start_counter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' start-counter')

		parser.add_argument('value_from', type=convert_int, help='int', metavar='<value-from>')
		parser.add_argument('value_to', type=convert_int, help='int', metavar='<value-to>')
		parser.add_argument('increment', type=convert_int, help='int', metavar='<increment>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_send_request(ctx, SegmentDisplay4x7Bricklet, 3, (args.value_from, args.value_to, args.increment, args.length), 'h h h I', '', None, args.expect_response, [], [])

	def get_counter_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-counter-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, SegmentDisplay4x7Bricklet, 4, (), '', 'H', args.execute, False, ['value'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SegmentDisplay4x7Bricklet, argv)

	functions = {
	'set-segments': set_segments,
	'get-segments': get_segments,
	'start-counter': start_counter,
	'get-counter-value': get_counter_value,
	'get-identity': get_identity
	}

	call_generic(ctx, 'segment-display-4x7-bricklet', functions, argv)

def dispatch_segment_display_4x7_bricklet(ctx, argv):
	prog_prefix = 'dispatch segment-display-4x7-bricklet <uid>'

	def counter_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' counter-finished')

		args = parser.parse_args(argv)

		device_callback(ctx, SegmentDisplay4x7Bricklet, 5, args.execute, [])

	callbacks = {
	'counter-finished': counter_finished
	}

	dispatch_generic(ctx, 'segment-display-4x7-bricklet', callbacks, argv)

class ServoBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 4; re[3] = 1; re[4] = 4; re[5] = 1; re[6] = 1; re[7] = 4; re[8] = 1; re[9] = 1; re[10] = 4; re[11] = 1; re[12] = 4; re[13] = 1; re[14] = 4; re[15] = 1; re[16] = 4; re[17] = 1; re[18] = 4; re[19] = 1; re[20] = 1; re[21] = 1; re[22] = 1; re[23] = 1; re[24] = 3; re[25] = 1; re[29] = 3; re[30] = 3; re[31] = 1; re[32] = 3; re[33] = 3; re[34] = 1; re[241] = 1; re[242] = 1; re[243] = 4; re[255] = 1
		cf = self.callback_formats
		cf[26] = 'H'; cf[27] = 'B h'; cf[28] = 'B h'

def call_servo_brick(ctx, argv):
	prog_prefix = 'call servo-brick <uid>'

	def enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 1, (args.servo_num,), 'B', '', None, args.expect_response, [], [])

	def disable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 2, (args.servo_num,), 'B', '', None, args.expect_response, [], [])

	def is_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-enabled')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 3, (args.servo_num,), 'B', '?', args.execute, False, ['enabled'], [None])

	def set_position(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 4, (args.servo_num, args.position), 'B h', '', None, args.expect_response, [], [])

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 5, (args.servo_num,), 'B', 'h', args.execute, False, ['position'], [None])

	def get_current_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-position')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 6, (args.servo_num,), 'B', 'h', args.execute, False, ['position'], [None])

	def set_velocity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-velocity')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('velocity', type=convert_int, help='int', metavar='<velocity>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 7, (args.servo_num, args.velocity), 'B H', '', None, args.expect_response, [], [])

	def get_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-velocity')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 8, (args.servo_num,), 'B', 'H', args.execute, False, ['velocity'], [None])

	def get_current_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-velocity')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 9, (args.servo_num,), 'B', 'H', args.execute, False, ['velocity'], [None])

	def set_acceleration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('acceleration', type=convert_int, help='int', metavar='<acceleration>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 10, (args.servo_num, args.acceleration), 'B H', '', None, args.expect_response, [], [])

	def get_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 11, (args.servo_num,), 'B', 'H', args.execute, False, ['acceleration'], [None])

	def set_output_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-output-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 12, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_output_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-output-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 13, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_pulse_width(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-pulse-width')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 14, (args.servo_num, args.min, args.max), 'B H H', '', None, args.expect_response, [], [])

	def get_pulse_width(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pulse-width')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 15, (args.servo_num,), 'B', 'H H', args.execute, False, ['min', 'max'], [None, None])

	def set_degree(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-degree')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 16, (args.servo_num, args.min, args.max), 'B h h', '', None, args.expect_response, [], [])

	def get_degree(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-degree')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 17, (args.servo_num,), 'B', 'h h', args.execute, False, ['min', 'max'], [None, None])

	def set_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-period')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 18, (args.servo_num, args.period), 'B H', '', None, args.expect_response, [], [])

	def get_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-period')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 19, (args.servo_num,), 'B', 'H', args.execute, False, ['period'], [None])

	def get_servo_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-servo-current')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 20, (args.servo_num,), 'B', 'H', args.execute, False, ['current'], [None])

	def get_overall_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-overall-current')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 21, (), '', 'H', args.execute, False, ['current'], [None])

	def get_stack_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-input-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 22, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_external_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-external-input-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 23, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_minimum_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-minimum-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 24, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_minimum_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-minimum-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 25, (), '', 'H', args.execute, False, ['voltage'], [None])

	def enable_position_reached_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-position-reached-callback')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 29, (), '', '', None, args.expect_response, [], [])

	def disable_position_reached_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-position-reached-callback')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 30, (), '', '', None, args.expect_response, [], [])

	def is_position_reached_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-position-reached-callback-enabled')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 31, (), '', 'B', args.execute, False, ['enabled'], [None])

	def enable_velocity_reached_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-velocity-reached-callback')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 32, (), '', '', None, args.expect_response, [], [])

	def disable_velocity_reached_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-velocity-reached-callback')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 33, (), '', '', None, args.expect_response, [], [])

	def is_velocity_reached_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-velocity-reached-callback-enabled')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 34, (), '', 'B', args.execute, False, ['enabled'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_send_request(ctx, ServoBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, ServoBrick, argv)

	functions = {
	'enable': enable,
	'disable': disable,
	'is-enabled': is_enabled,
	'set-position': set_position,
	'get-position': get_position,
	'get-current-position': get_current_position,
	'set-velocity': set_velocity,
	'get-velocity': get_velocity,
	'get-current-velocity': get_current_velocity,
	'set-acceleration': set_acceleration,
	'get-acceleration': get_acceleration,
	'set-output-voltage': set_output_voltage,
	'get-output-voltage': get_output_voltage,
	'set-pulse-width': set_pulse_width,
	'get-pulse-width': get_pulse_width,
	'set-degree': set_degree,
	'get-degree': get_degree,
	'set-period': set_period,
	'get-period': get_period,
	'get-servo-current': get_servo_current,
	'get-overall-current': get_overall_current,
	'get-stack-input-voltage': get_stack_input_voltage,
	'get-external-input-voltage': get_external_input_voltage,
	'set-minimum-voltage': set_minimum_voltage,
	'get-minimum-voltage': get_minimum_voltage,
	'enable-position-reached-callback': enable_position_reached_callback,
	'disable-position-reached-callback': disable_position_reached_callback,
	'is-position-reached-callback-enabled': is_position_reached_callback_enabled,
	'enable-velocity-reached-callback': enable_velocity_reached_callback,
	'disable-velocity-reached-callback': disable_velocity_reached_callback,
	'is-velocity-reached-callback-enabled': is_velocity_reached_callback_enabled,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'servo-brick', functions, argv)

def dispatch_servo_brick(ctx, argv):
	prog_prefix = 'dispatch servo-brick <uid>'

	def under_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' under-voltage')

		args = parser.parse_args(argv)

		device_callback(ctx, ServoBrick, 26, args.execute, ['voltage'])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, ServoBrick, 27, args.execute, ['servo-num', 'position'])

	def velocity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' velocity-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, ServoBrick, 28, args.execute, ['servo-num', 'velocity'])

	callbacks = {
	'under-voltage': under_voltage,
	'position-reached': position_reached,
	'velocity-reached': velocity_reached
	}

	dispatch_generic(ctx, 'servo-brick', callbacks, argv)

class SolidStateRelayBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 4; re[4] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = '?'

def call_solid_state_relay_bricklet(ctx, argv):
	prog_prefix = 'call solid-state-relay-bricklet <uid>'

	def set_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-state')

		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')

		args = parser.parse_args(argv)

		device_send_request(ctx, SolidStateRelayBricklet, 1, (args.state,), '?', '', None, args.expect_response, [], [])

	def get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-state')

		args = parser.parse_args(argv)

		device_send_request(ctx, SolidStateRelayBricklet, 2, (), '', '?', args.execute, False, ['state'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_send_request(ctx, SolidStateRelayBricklet, 3, (args.state, args.time), '? I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		args = parser.parse_args(argv)

		device_send_request(ctx, SolidStateRelayBricklet, 4, (), '', '? I I', args.execute, False, ['state', 'time', 'time-remaining'], [None, None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SolidStateRelayBricklet, argv)

	functions = {
	'set-state': set_state,
	'get-state': get_state,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'get-identity': get_identity
	}

	call_generic(ctx, 'solid-state-relay-bricklet', functions, argv)

def dispatch_solid_state_relay_bricklet(ctx, argv):
	prog_prefix = 'dispatch solid-state-relay-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_callback(ctx, SolidStateRelayBricklet, 5, args.execute, ['state'])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'solid-state-relay-bricklet', callbacks, argv)

class SoundIntensityBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'

def call_sound_intensity_bricklet(ctx, argv):
	prog_prefix = 'call sound-intensity-bricklet <uid>'

	def get_intensity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-intensity')

		args = parser.parse_args(argv)

		device_send_request(ctx, SoundIntensityBricklet, 1, (), '', 'H', args.execute, False, ['intensity'], [None])

	def set_intensity_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-intensity-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, SoundIntensityBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_intensity_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-intensity-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, SoundIntensityBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_intensity_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-intensity-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, SoundIntensityBricklet, 4, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_intensity_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-intensity-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, SoundIntensityBricklet, 5, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, SoundIntensityBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, SoundIntensityBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SoundIntensityBricklet, argv)

	functions = {
	'get-intensity': get_intensity,
	'set-intensity-callback-period': set_intensity_callback_period,
	'get-intensity-callback-period': get_intensity_callback_period,
	'set-intensity-callback-threshold': set_intensity_callback_threshold,
	'get-intensity-callback-threshold': get_intensity_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'sound-intensity-bricklet', functions, argv)

def dispatch_sound_intensity_bricklet(ctx, argv):
	prog_prefix = 'dispatch sound-intensity-bricklet <uid>'

	def intensity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' intensity')

		args = parser.parse_args(argv)

		device_callback(ctx, SoundIntensityBricklet, 8, args.execute, ['intensity'])

	def intensity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' intensity-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, SoundIntensityBricklet, 9, args.execute, ['intensity'])

	callbacks = {
	'intensity': intensity,
	'intensity-reached': intensity_reached
	}

	dispatch_generic(ctx, 'sound-intensity-bricklet', callbacks, argv)

class StepperBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 4; re[2] = 1; re[3] = 1; re[4] = 4; re[5] = 1; re[6] = 4; re[7] = 4; re[8] = 1; re[9] = 4; re[10] = 1; re[11] = 4; re[12] = 1; re[13] = 1; re[14] = 4; re[15] = 1; re[16] = 4; re[17] = 4; re[18] = 4; re[19] = 1; re[20] = 1; re[21] = 1; re[22] = 4; re[23] = 1; re[24] = 4; re[25] = 4; re[26] = 1; re[27] = 4; re[28] = 1; re[29] = 3; re[30] = 1; re[33] = 4; re[34] = 1; re[35] = 4; re[36] = 1; re[37] = 1; re[38] = 3; re[39] = 1; re[241] = 1; re[242] = 1; re[243] = 4; re[255] = 1
		cf = self.callback_formats
		cf[31] = 'H'; cf[32] = 'i'; cf[40] = 'H i i H H H'; cf[41] = 'B B'

def call_stepper_brick(ctx, argv):
	prog_prefix = 'call stepper-brick <uid>'

	def set_max_velocity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-max-velocity')

		parser.add_argument('velocity', type=convert_int, help='int', metavar='<velocity>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 1, (args.velocity,), 'H', '', None, args.expect_response, [], [])

	def get_max_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-max-velocity')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 2, (), '', 'H', args.execute, False, ['velocity'], [None])

	def get_current_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-velocity')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 3, (), '', 'H', args.execute, False, ['velocity'], [None])

	def set_speed_ramping(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-speed-ramping')

		parser.add_argument('acceleration', type=convert_int, help='int', metavar='<acceleration>')
		parser.add_argument('deacceleration', type=convert_int, help='int', metavar='<deacceleration>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 4, (args.acceleration, args.deacceleration), 'H H', '', None, args.expect_response, [], [])

	def get_speed_ramping(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-speed-ramping')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 5, (), '', 'H H', args.execute, False, ['acceleration', 'deacceleration'], [None, None])

	def full_brake(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' full-brake')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 6, (), '', '', None, args.expect_response, [], [])

	def set_current_position(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-position')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 7, (args.position,), 'i', '', None, args.expect_response, [], [])

	def get_current_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-position')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 8, (), '', 'i', args.execute, False, ['position'], [None])

	def set_target_position(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-target-position')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 9, (args.position,), 'i', '', None, args.expect_response, [], [])

	def get_target_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-target-position')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 10, (), '', 'i', args.execute, False, ['position'], [None])

	def set_steps(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-steps')

		parser.add_argument('steps', type=convert_int, help='int', metavar='<steps>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 11, (args.steps,), 'i', '', None, args.expect_response, [], [])

	def get_steps(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-steps')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 12, (), '', 'i', args.execute, False, ['steps'], [None])

	def get_remaining_steps(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-remaining-steps')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 13, (), '', 'i', args.execute, False, ['steps'], [None])

	def set_step_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-step-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'eighth-step': 8, 'quarter-step': 4, 'half-step': 2, 'full-step': 1}), help='int (full-step: 1, half-step: 2, quarter-step: 4, eighth-step: 8)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 14, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_step_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-step-mode')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 15, (), '', 'B', args.execute, False, ['mode'], [{8: 'eighth-step', 1: 'full-step', 2: 'half-step', 4: 'quarter-step'}])

	def drive_forward(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' drive-forward')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 16, (), '', '', None, args.expect_response, [], [])

	def drive_backward(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' drive-backward')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 17, (), '', '', None, args.expect_response, [], [])

	def stop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' stop')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 18, (), '', '', None, args.expect_response, [], [])

	def get_stack_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-input-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 19, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_external_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-external-input-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 20, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_current_consumption(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-consumption')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 21, (), '', 'H', args.execute, False, ['current'], [None])

	def set_motor_current(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-motor-current')

		parser.add_argument('current', type=convert_int, help='int', metavar='<current>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 22, (args.current,), 'H', '', None, args.expect_response, [], [])

	def get_motor_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motor-current')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 23, (), '', 'H', args.execute, False, ['current'], [None])

	def enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 24, (), '', '', None, args.expect_response, [], [])

	def disable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 25, (), '', '', None, args.expect_response, [], [])

	def is_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-enabled')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 26, (), '', '?', args.execute, False, ['enabled'], [None])

	def set_decay(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-decay')

		parser.add_argument('decay', type=convert_int, help='int', metavar='<decay>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 27, (args.decay,), 'H', '', None, args.expect_response, [], [])

	def get_decay(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-decay')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 28, (), '', 'H', args.execute, False, ['decay'], [None])

	def set_minimum_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-minimum-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 29, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_minimum_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-minimum-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 30, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_sync_rect(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sync-rect')

		parser.add_argument('sync_rect', type=convert_bool, help='bool', metavar='<sync-rect>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 33, (args.sync_rect,), '?', '', None, args.expect_response, [], [])

	def is_sync_rect(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-sync-rect')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 34, (), '', '?', args.execute, False, ['sync-rect'], [None])

	def set_time_base(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-time-base')

		parser.add_argument('time_base', type=convert_int, help='int', metavar='<time-base>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 35, (args.time_base,), 'I', '', None, args.expect_response, [], [])

	def get_time_base(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-time-base')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 36, (), '', 'I', args.execute, False, ['time-base'], [None])

	def get_all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 37, (), '', 'H i i H H H', args.execute, False, ['current-velocity', 'current-position', 'remaining-steps', 'stack-voltage', 'external-voltage', 'current-consumption'], [None, None, None, None, None, None])

	def set_all_data_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-data-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 38, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_all_data_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 39, (), '', 'I', args.execute, False, ['period'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=check_char, help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_send_request(ctx, StepperBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, StepperBrick, argv)

	functions = {
	'set-max-velocity': set_max_velocity,
	'get-max-velocity': get_max_velocity,
	'get-current-velocity': get_current_velocity,
	'set-speed-ramping': set_speed_ramping,
	'get-speed-ramping': get_speed_ramping,
	'full-brake': full_brake,
	'set-current-position': set_current_position,
	'get-current-position': get_current_position,
	'set-target-position': set_target_position,
	'get-target-position': get_target_position,
	'set-steps': set_steps,
	'get-steps': get_steps,
	'get-remaining-steps': get_remaining_steps,
	'set-step-mode': set_step_mode,
	'get-step-mode': get_step_mode,
	'drive-forward': drive_forward,
	'drive-backward': drive_backward,
	'stop': stop,
	'get-stack-input-voltage': get_stack_input_voltage,
	'get-external-input-voltage': get_external_input_voltage,
	'get-current-consumption': get_current_consumption,
	'set-motor-current': set_motor_current,
	'get-motor-current': get_motor_current,
	'enable': enable,
	'disable': disable,
	'is-enabled': is_enabled,
	'set-decay': set_decay,
	'get-decay': get_decay,
	'set-minimum-voltage': set_minimum_voltage,
	'get-minimum-voltage': get_minimum_voltage,
	'set-sync-rect': set_sync_rect,
	'is-sync-rect': is_sync_rect,
	'set-time-base': set_time_base,
	'get-time-base': get_time_base,
	'get-all-data': get_all_data,
	'set-all-data-period': set_all_data_period,
	'get-all-data-period': get_all_data_period,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'stepper-brick', functions, argv)

def dispatch_stepper_brick(ctx, argv):
	prog_prefix = 'dispatch stepper-brick <uid>'

	def under_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' under-voltage')

		args = parser.parse_args(argv)

		device_callback(ctx, StepperBrick, 31, args.execute, ['voltage'])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, StepperBrick, 32, args.execute, ['position'])

	def all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-data')

		args = parser.parse_args(argv)

		device_callback(ctx, StepperBrick, 40, args.execute, ['current-velocity', 'current-position', 'remaining-steps', 'stack-voltage', 'external-voltage', 'current-consumption'])

	def new_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' new-state')

		args = parser.parse_args(argv)

		device_callback(ctx, StepperBrick, 41, args.execute, ['state-new', 'state-previous'])

	callbacks = {
	'under-voltage': under_voltage,
	'position-reached': position_reached,
	'all-data': all_data,
	'new-state': new_state
	}

	dispatch_generic(ctx, 'stepper-brick', callbacks, argv)

class TemperatureBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[10] = 4; re[11] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'h'; cf[9] = 'h'

def call_temperature_bricklet(ctx, argv):
	prog_prefix = 'call temperature-bricklet <uid>'

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureBricklet, 1, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureBricklet, 4, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureBricklet, 5, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_i2c_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-i2c-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'slow': 1, 'fast': 0}), help='int (fast: 0, slow: 1)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureBricklet, 10, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_i2c_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-i2c-mode')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureBricklet, 11, (), '', 'B', args.execute, False, ['mode'], [{0: 'fast', 1: 'slow'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, TemperatureBricklet, argv)

	functions = {
	'get-temperature': get_temperature,
	'set-temperature-callback-period': set_temperature_callback_period,
	'get-temperature-callback-period': get_temperature_callback_period,
	'set-temperature-callback-threshold': set_temperature_callback_threshold,
	'get-temperature-callback-threshold': get_temperature_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-i2c-mode': set_i2c_mode,
	'get-i2c-mode': get_i2c_mode,
	'get-identity': get_identity
	}

	call_generic(ctx, 'temperature-bricklet', functions, argv)

def dispatch_temperature_bricklet(ctx, argv):
	prog_prefix = 'dispatch temperature-bricklet <uid>'

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_callback(ctx, TemperatureBricklet, 8, args.execute, ['temperature'])

	def temperature_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, TemperatureBricklet, 9, args.execute, ['temperature'])

	callbacks = {
	'temperature': temperature,
	'temperature-reached': temperature_reached
	}

	dispatch_generic(ctx, 'temperature-bricklet', callbacks, argv)

class TemperatureIRBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 4; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'h'; cf[16] = 'h'; cf[17] = 'h'; cf[18] = 'h'

def call_temperature_ir_bricklet(ctx, argv):
	prog_prefix = 'call temperature-ir-bricklet <uid>'

	def get_ambient_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ambient-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 1, (), '', 'h', args.execute, False, ['temperature'], [None])

	def get_object_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-object-temperature')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 2, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_emissivity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-emissivity')

		parser.add_argument('emissivity', type=convert_int, help='int', metavar='<emissivity>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 3, (args.emissivity,), 'H', '', None, args.expect_response, [], [])

	def get_emissivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-emissivity')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 4, (), '', 'H', args.execute, False, ['emissivity'], [None])

	def set_ambient_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ambient-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_ambient_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ambient-temperature-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_object_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-object-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_object_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-object-temperature-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_ambient_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ambient-temperature-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 9, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_ambient_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ambient-temperature-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 10, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_object_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-object-temperature-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 11, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_object_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-object-temperature-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 12, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, TemperatureIRBricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, TemperatureIRBricklet, argv)

	functions = {
	'get-ambient-temperature': get_ambient_temperature,
	'get-object-temperature': get_object_temperature,
	'set-emissivity': set_emissivity,
	'get-emissivity': get_emissivity,
	'set-ambient-temperature-callback-period': set_ambient_temperature_callback_period,
	'get-ambient-temperature-callback-period': get_ambient_temperature_callback_period,
	'set-object-temperature-callback-period': set_object_temperature_callback_period,
	'get-object-temperature-callback-period': get_object_temperature_callback_period,
	'set-ambient-temperature-callback-threshold': set_ambient_temperature_callback_threshold,
	'get-ambient-temperature-callback-threshold': get_ambient_temperature_callback_threshold,
	'set-object-temperature-callback-threshold': set_object_temperature_callback_threshold,
	'get-object-temperature-callback-threshold': get_object_temperature_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'temperature-ir-bricklet', functions, argv)

def dispatch_temperature_ir_bricklet(ctx, argv):
	prog_prefix = 'dispatch temperature-ir-bricklet <uid>'

	def ambient_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' ambient-temperature')

		args = parser.parse_args(argv)

		device_callback(ctx, TemperatureIRBricklet, 15, args.execute, ['temperature'])

	def object_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' object-temperature')

		args = parser.parse_args(argv)

		device_callback(ctx, TemperatureIRBricklet, 16, args.execute, ['temperature'])

	def ambient_temperature_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' ambient-temperature-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, TemperatureIRBricklet, 17, args.execute, ['temperature'])

	def object_temperature_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' object-temperature-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, TemperatureIRBricklet, 18, args.execute, ['temperature'])

	callbacks = {
	'ambient-temperature': ambient_temperature,
	'object-temperature': object_temperature,
	'ambient-temperature-reached': ambient_temperature_reached,
	'object-temperature-reached': object_temperature_reached
	}

	dispatch_generic(ctx, 'temperature-ir-bricklet', callbacks, argv)

class TiltBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 3; re[4] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = 'B'

def call_tilt_bricklet(ctx, argv):
	prog_prefix = 'call tilt-bricklet <uid>'

	def get_tilt_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-tilt-state')

		args = parser.parse_args(argv)

		device_send_request(ctx, TiltBricklet, 1, (), '', 'B', args.execute, False, ['state'], [{0: 'closed', 1: 'open', 2: 'closed-vibrating'}])

	def enable_tilt_state_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-tilt-state-callback')

		args = parser.parse_args(argv)

		device_send_request(ctx, TiltBricklet, 2, (), '', '', None, args.expect_response, [], [])

	def disable_tilt_state_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-tilt-state-callback')

		args = parser.parse_args(argv)

		device_send_request(ctx, TiltBricklet, 3, (), '', '', None, args.expect_response, [], [])

	def is_tilt_state_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-tilt-state-callback-enabled')

		args = parser.parse_args(argv)

		device_send_request(ctx, TiltBricklet, 4, (), '', '?', args.execute, False, ['enabled'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, TiltBricklet, argv)

	functions = {
	'get-tilt-state': get_tilt_state,
	'enable-tilt-state-callback': enable_tilt_state_callback,
	'disable-tilt-state-callback': disable_tilt_state_callback,
	'is-tilt-state-callback-enabled': is_tilt_state_callback_enabled,
	'get-identity': get_identity
	}

	call_generic(ctx, 'tilt-bricklet', functions, argv)

def dispatch_tilt_bricklet(ctx, argv):
	prog_prefix = 'dispatch tilt-bricklet <uid>'

	def tilt_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' tilt-state')

		args = parser.parse_args(argv)

		device_callback(ctx, TiltBricklet, 5, args.execute, ['state'])

	callbacks = {
	'tilt-state': tilt_state
	}

	dispatch_generic(ctx, 'tilt-bricklet', callbacks, argv)

class VoltageBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'

def call_voltage_bricklet(ctx, argv):
	prog_prefix = 'call voltage-bricklet <uid>'

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 1, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 7, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 8, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, VoltageBricklet, argv)

	functions = {
	'get-voltage': get_voltage,
	'get-analog-value': get_analog_value,
	'set-voltage-callback-period': set_voltage_callback_period,
	'get-voltage-callback-period': get_voltage_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-voltage-callback-threshold': set_voltage_callback_threshold,
	'get-voltage-callback-threshold': get_voltage_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'voltage-bricklet', functions, argv)

def dispatch_voltage_bricklet(ctx, argv):
	prog_prefix = 'dispatch voltage-bricklet <uid>'

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageBricklet, 13, args.execute, ['voltage'])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageBricklet, 14, args.execute, ['value'])

	def voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageBricklet, 15, args.execute, ['voltage'])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageBricklet, 16, args.execute, ['value'])

	callbacks = {
	'voltage': voltage,
	'analog-value': analog_value,
	'voltage-reached': voltage_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'voltage-bricklet', callbacks, argv)

class VoltageCurrentBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 4; re[5] = 1; re[6] = 4; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 3; re[11] = 1; re[12] = 3; re[13] = 1; re[14] = 3; re[15] = 1; re[16] = 3; re[17] = 1; re[18] = 3; re[19] = 1; re[20] = 3; re[21] = 1; re[255] = 1
		cf = self.callback_formats
		cf[22] = 'i'; cf[23] = 'i'; cf[24] = 'i'; cf[25] = 'i'; cf[26] = 'i'; cf[27] = 'i'

def call_voltage_current_bricklet(ctx, argv):
	prog_prefix = 'call voltage-current-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 1, (), '', 'i', args.execute, False, ['current'], [None])

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 2, (), '', 'i', args.execute, False, ['voltage'], [None])

	def get_power(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-power')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 3, (), '', 'i', args.execute, False, ['power'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('averaging', type=create_symbol_converter(ctx, convert_int, {'1024': 7, '16': 2, '1': 0, '64': 3, '4': 1, '128': 4, '512': 6, '256': 5}), help='int (1: 0, 4: 1, 16: 2, 64: 3, 128: 4, 256: 5, 512: 6, 1024: 7)', metavar='<averaging>')
		parser.add_argument('voltage_conversion_time', type=convert_int, help='int', metavar='<voltage-conversion-time>')
		parser.add_argument('current_conversion_time', type=convert_int, help='int', metavar='<current-conversion-time>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 4, (args.averaging, args.voltage_conversion_time, args.current_conversion_time), 'B B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 5, (), '', 'B B B', args.execute, False, ['averaging', 'voltage-conversion-time', 'current-conversion-time'], [{0: '1', 1: '4', 2: '16', 3: '64', 4: '128', 5: '256', 6: '512', 7: '1024'}, None, None])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('gain_multiplier', type=convert_int, help='int', metavar='<gain-multiplier>')
		parser.add_argument('gain_divisor', type=convert_int, help='int', metavar='<gain-divisor>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 6, (args.gain_multiplier, args.gain_divisor), 'H H', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 7, (), '', 'H H', args.execute, False, ['gain-multiplier', 'gain-divisor'], [None, None])

	def set_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 8, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 9, (), '', 'I', args.execute, False, ['period'], [None])

	def set_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 10, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 11, (), '', 'I', args.execute, False, ['period'], [None])

	def set_power_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-power-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 12, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_power_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-power-callback-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 13, (), '', 'I', args.execute, False, ['period'], [None])

	def set_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 14, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 15, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 16, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 17, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_power_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-power-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, check_char, {'outside': 'o', 'smaller': '<', 'off': 'x', 'inside': 'i', 'greater': '>'}), help='char (off: x, outside: o, inside: i, smaller: <, greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 18, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_power_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-power-callback-threshold')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 19, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'inside', 'x': 'off', '<': 'smaller', 'o': 'outside', '>': 'greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 20, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_send_request(ctx, VoltageCurrentBricklet, 21, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, VoltageCurrentBricklet, argv)

	functions = {
	'get-current': get_current,
	'get-voltage': get_voltage,
	'get-power': get_power,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'set-current-callback-period': set_current_callback_period,
	'get-current-callback-period': get_current_callback_period,
	'set-voltage-callback-period': set_voltage_callback_period,
	'get-voltage-callback-period': get_voltage_callback_period,
	'set-power-callback-period': set_power_callback_period,
	'get-power-callback-period': get_power_callback_period,
	'set-current-callback-threshold': set_current_callback_threshold,
	'get-current-callback-threshold': get_current_callback_threshold,
	'set-voltage-callback-threshold': set_voltage_callback_threshold,
	'get-voltage-callback-threshold': get_voltage_callback_threshold,
	'set-power-callback-threshold': set_power_callback_threshold,
	'get-power-callback-threshold': get_power_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'voltage-current-bricklet', functions, argv)

def dispatch_voltage_current_bricklet(ctx, argv):
	prog_prefix = 'dispatch voltage-current-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageCurrentBricklet, 22, args.execute, ['current'])

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageCurrentBricklet, 23, args.execute, ['voltage'])

	def power(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' power')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageCurrentBricklet, 24, args.execute, ['power'])

	def current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageCurrentBricklet, 25, args.execute, ['current'])

	def voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageCurrentBricklet, 26, args.execute, ['voltage'])

	def power_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' power-reached')

		args = parser.parse_args(argv)

		device_callback(ctx, VoltageCurrentBricklet, 27, args.execute, ['power'])

	callbacks = {
	'current': current,
	'voltage': voltage,
	'power': power,
	'current-reached': current_reached,
	'voltage-reached': voltage_reached,
	'power-reached': power_reached
	}

	dispatch_generic(ctx, 'voltage-current-bricklet', callbacks, argv)

call_devices = {
'dc-brick': call_dc_brick,
'imu-brick': call_imu_brick,
'master-brick': call_master_brick,
'red-brick': call_red_brick,
'servo-brick': call_servo_brick,
'stepper-brick': call_stepper_brick,
'ambient-light-bricklet': call_ambient_light_bricklet,
'analog-in-bricklet': call_analog_in_bricklet,
'analog-out-bricklet': call_analog_out_bricklet,
'barometer-bricklet': call_barometer_bricklet,
'color-bricklet': call_color_bricklet,
'current12-bricklet': call_current12_bricklet,
'current25-bricklet': call_current25_bricklet,
'distance-ir-bricklet': call_distance_ir_bricklet,
'distance-us-bricklet': call_distance_us_bricklet,
'dual-button-bricklet': call_dual_button_bricklet,
'dual-relay-bricklet': call_dual_relay_bricklet,
'gps-bricklet': call_gps_bricklet,
'hall-effect-bricklet': call_hall_effect_bricklet,
'humidity-bricklet': call_humidity_bricklet,
'industrial-digital-in-4-bricklet': call_industrial_digital_in_4_bricklet,
'industrial-digital-out-4-bricklet': call_industrial_digital_out_4_bricklet,
'industrial-dual-0-20ma-bricklet': call_industrial_dual_0_20ma_bricklet,
'industrial-quad-relay-bricklet': call_industrial_quad_relay_bricklet,
'io16-bricklet': call_io16_bricklet,
'io4-bricklet': call_io4_bricklet,
'joystick-bricklet': call_joystick_bricklet,
'lcd-16x2-bricklet': call_lcd_16x2_bricklet,
'lcd-20x4-bricklet': call_lcd_20x4_bricklet,
'led-strip-bricklet': call_led_strip_bricklet,
'line-bricklet': call_line_bricklet,
'linear-poti-bricklet': call_linear_poti_bricklet,
'moisture-bricklet': call_moisture_bricklet,
'motion-detector-bricklet': call_motion_detector_bricklet,
'multi-touch-bricklet': call_multi_touch_bricklet,
'nfc-rfid-bricklet': call_nfc_rfid_bricklet,
'piezo-buzzer-bricklet': call_piezo_buzzer_bricklet,
'piezo-speaker-bricklet': call_piezo_speaker_bricklet,
'ptc-bricklet': call_ptc_bricklet,
'remote-switch-bricklet': call_remote_switch_bricklet,
'rotary-encoder-bricklet': call_rotary_encoder_bricklet,
'rotary-poti-bricklet': call_rotary_poti_bricklet,
'segment-display-4x7-bricklet': call_segment_display_4x7_bricklet,
'solid-state-relay-bricklet': call_solid_state_relay_bricklet,
'sound-intensity-bricklet': call_sound_intensity_bricklet,
'temperature-bricklet': call_temperature_bricklet,
'temperature-ir-bricklet': call_temperature_ir_bricklet,
'tilt-bricklet': call_tilt_bricklet,
'voltage-bricklet': call_voltage_bricklet,
'voltage-current-bricklet': call_voltage_current_bricklet
}

dispatch_devices = {
'dc-brick': dispatch_dc_brick,
'imu-brick': dispatch_imu_brick,
'master-brick': dispatch_master_brick,
'red-brick': dispatch_red_brick,
'servo-brick': dispatch_servo_brick,
'stepper-brick': dispatch_stepper_brick,
'ambient-light-bricklet': dispatch_ambient_light_bricklet,
'analog-in-bricklet': dispatch_analog_in_bricklet,
'analog-out-bricklet': dispatch_analog_out_bricklet,
'barometer-bricklet': dispatch_barometer_bricklet,
'color-bricklet': dispatch_color_bricklet,
'current12-bricklet': dispatch_current12_bricklet,
'current25-bricklet': dispatch_current25_bricklet,
'distance-ir-bricklet': dispatch_distance_ir_bricklet,
'distance-us-bricklet': dispatch_distance_us_bricklet,
'dual-button-bricklet': dispatch_dual_button_bricklet,
'dual-relay-bricklet': dispatch_dual_relay_bricklet,
'gps-bricklet': dispatch_gps_bricklet,
'hall-effect-bricklet': dispatch_hall_effect_bricklet,
'humidity-bricklet': dispatch_humidity_bricklet,
'industrial-digital-in-4-bricklet': dispatch_industrial_digital_in_4_bricklet,
'industrial-digital-out-4-bricklet': dispatch_industrial_digital_out_4_bricklet,
'industrial-dual-0-20ma-bricklet': dispatch_industrial_dual_0_20ma_bricklet,
'industrial-quad-relay-bricklet': dispatch_industrial_quad_relay_bricklet,
'io16-bricklet': dispatch_io16_bricklet,
'io4-bricklet': dispatch_io4_bricklet,
'joystick-bricklet': dispatch_joystick_bricklet,
'lcd-16x2-bricklet': dispatch_lcd_16x2_bricklet,
'lcd-20x4-bricklet': dispatch_lcd_20x4_bricklet,
'led-strip-bricklet': dispatch_led_strip_bricklet,
'line-bricklet': dispatch_line_bricklet,
'linear-poti-bricklet': dispatch_linear_poti_bricklet,
'moisture-bricklet': dispatch_moisture_bricklet,
'motion-detector-bricklet': dispatch_motion_detector_bricklet,
'multi-touch-bricklet': dispatch_multi_touch_bricklet,
'nfc-rfid-bricklet': dispatch_nfc_rfid_bricklet,
'piezo-buzzer-bricklet': dispatch_piezo_buzzer_bricklet,
'piezo-speaker-bricklet': dispatch_piezo_speaker_bricklet,
'ptc-bricklet': dispatch_ptc_bricklet,
'remote-switch-bricklet': dispatch_remote_switch_bricklet,
'rotary-encoder-bricklet': dispatch_rotary_encoder_bricklet,
'rotary-poti-bricklet': dispatch_rotary_poti_bricklet,
'segment-display-4x7-bricklet': dispatch_segment_display_4x7_bricklet,
'solid-state-relay-bricklet': dispatch_solid_state_relay_bricklet,
'sound-intensity-bricklet': dispatch_sound_intensity_bricklet,
'temperature-bricklet': dispatch_temperature_bricklet,
'temperature-ir-bricklet': dispatch_temperature_ir_bricklet,
'tilt-bricklet': dispatch_tilt_bricklet,
'voltage-bricklet': dispatch_voltage_bricklet,
'voltage-current-bricklet': dispatch_voltage_current_bricklet
}

device_identifier_symbols = {
11: 'dc-brick',
16: 'imu-brick',
13: 'master-brick',
17: 'red-brick',
14: 'servo-brick',
15: 'stepper-brick',
21: 'ambient-light-bricklet',
219: 'analog-in-bricklet',
220: 'analog-out-bricklet',
221: 'barometer-bricklet',
243: 'color-bricklet',
23: 'current12-bricklet',
24: 'current25-bricklet',
25: 'distance-ir-bricklet',
229: 'distance-us-bricklet',
230: 'dual-button-bricklet',
26: 'dual-relay-bricklet',
222: 'gps-bricklet',
240: 'hall-effect-bricklet',
27: 'humidity-bricklet',
223: 'industrial-digital-in-4-bricklet',
224: 'industrial-digital-out-4-bricklet',
228: 'industrial-dual-0-20ma-bricklet',
225: 'industrial-quad-relay-bricklet',
28: 'io16-bricklet',
29: 'io4-bricklet',
210: 'joystick-bricklet',
211: 'lcd-16x2-bricklet',
212: 'lcd-20x4-bricklet',
231: 'led-strip-bricklet',
241: 'line-bricklet',
213: 'linear-poti-bricklet',
232: 'moisture-bricklet',
233: 'motion-detector-bricklet',
234: 'multi-touch-bricklet',
246: 'nfc-rfid-bricklet',
214: 'piezo-buzzer-bricklet',
242: 'piezo-speaker-bricklet',
226: 'ptc-bricklet',
235: 'remote-switch-bricklet',
236: 'rotary-encoder-bricklet',
215: 'rotary-poti-bricklet',
237: 'segment-display-4x7-bricklet',
244: 'solid-state-relay-bricklet',
238: 'sound-intensity-bricklet',
216: 'temperature-bricklet',
217: 'temperature-ir-bricklet',
239: 'tilt-bricklet',
218: 'voltage-bricklet',
227: 'voltage-current-bricklet'
}

def command_call(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'call')
	device_choices = sorted(call_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(device_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--timeout', default=2500, type=convert_int, help='maximum time (msec) to wait for response, default: 2500', metavar='<timeout>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.timeout = args.timeout

	call_devices[args.device](ctx, args.args)

def command_dispatch(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'dispatch')
	device_choices = sorted(dispatch_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(device_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--duration', default=-1, type=create_symbol_converter(ctx, int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate callbacks (exit-after-first: 0, forever: -1), default: forever', metavar='<duration>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.duration = args.duration

	dispatch_devices[args.device](ctx, args.args)

def command_enumerate(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'enumerate')

	enumeration_type_symbols = {
	'available': IPConnection.ENUMERATION_TYPE_AVAILABLE,
	'connected': IPConnection.ENUMERATION_TYPE_CONNECTED,
	'disconnected': IPConnection.ENUMERATION_TYPE_DISCONNECTED,
	'all': -1
	}

	parser.add_argument('--duration', default=250, type=create_symbol_converter(ctx, int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate responses (exit-after-first: 0, forever: -1), default: 250', metavar='<duration>')
	parser.add_argument('--types', default=[IPConnection.ENUMERATION_TYPE_AVAILABLE], type=create_array_converter(ctx, create_symbol_converter(ctx, int, enumeration_type_symbols, True), 3, False), help='array of enumeration types to dispatch (available: 0, connected: 1, disconnected: 2, all: -1), default: available', metavar='<types>')

	if enable_execute:
		parser.add_argument('--execute', type=str, help='shell command line to execute for each incoming response', metavar='<command>')

	namespace = argparse.Namespace()

	if not enable_execute:
		setattr(namespace, 'execute', None)

	args = parser.parse_args(argv, namespace)

	if dry_run:
		return

	names = ['uid', 'connected-uid', 'position', 'hardware-version', 'firmware-version', 'device-identifier', 'enumeration-type']
	enumeration_type_symbols = {
	IPConnection.ENUMERATION_TYPE_AVAILABLE: 'available',
	IPConnection.ENUMERATION_TYPE_CONNECTED: 'connected',
	IPConnection.ENUMERATION_TYPE_DISCONNECTED: 'disconnected'
	}
	symbols = [None, None, None, None, None, device_identifier_symbols, enumeration_type_symbols]
	is_first_callback = [True]

	def fix_position(values):
		if values[2] == '\0':
			values = list(values)
			values[2] = 'x'
			values = tuple(values)

		return values

	if args.execute is not None:
		def callback(*values):
			if -1 in args.types or values[6] in args.types:
				values = format_symbolic_output(ctx, fix_position(values), symbols)

				execute_response(ctx, args.execute, names, values)
				return True
	else:
		def callback(*values):
			if -1 in args.types or values[6] in args.types:
				if not listen_mode:
					if is_first_callback[0]:
						is_first_callback[0] = False
					else:
						ctx.output(ctx.group_separator)

				values = format_symbolic_output(ctx, fix_position(values), symbols)

				output_response(ctx, names, values)
				return True

	def function(ipcon):
		if args.duration == 0:
			exit_flag = [False]

			def callback_wrapper(*args, **kwargs):
				if not exit_flag[0] and callback(*args, **kwargs):
					exit_flag[0] = True

			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback_wrapper)
			ipcon.enumerate()

			while not exit_flag[0] and not ctx.abort:
				time.sleep(0.1)

				if ctx.async_exception is not None:
					raise ctx.async_exception
		elif args.duration < 0:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			while not ctx.abort:
				time.sleep(1)

				if ctx.async_exception is not None:
					raise ctx.async_exception
		else:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			# FIXME: if duration is large then it would be better to sleep
			#        in multiple steps here
			time.sleep(args.duration / 1000.0)

			# FIXME: only checking for an exception after the complete sleep
			#        is not good, sleep in shorter steps here to check for
			#        exception more often
			if ctx.async_exception is not None:
				raise ctx.async_exception

	connect_ipcon_and_call(ctx, function)

def command_listen(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'listen', epilog="In listen mode some command line options are disabled by default for incoming commands.\n\nThe --host and --port options are disabled by default so incoming commands can only connect to the host and port given to the listen command. Use --enable-host and --enable-port to enable these options for incoming commands.\n\nThe --execute option for getter calls and callback dispatching is disabled by default so incoming command cannot execute other commands. Use --enable-execute to enable this option for incoming commands.\n\nNo group separator is included in the output and the --group-separator option is ignored.\n\nIncoming commands have to be terminated by \\n. The output is also terminated by \\n.")

	parser.add_argument('--address', default='0.0.0.0', type=str, help='IP address to listen to, default: 0.0.0.0', metavar='<address>')
	parser.add_argument('--port', default=4217, type=convert_int, help='port number to listen to, default: 4217', metavar='<port>')
	parser.add_argument('--enable-host', action='store_true', help='enables --host option to override IP address or hostname to connect to')
	parser.add_argument('--enable-port', action='store_true', help='enables --port option to override port number to connect to')
	parser.add_argument('--enable-execute', action='store_true', help='enables --execute option for getters and callbacks')

	args = parser.parse_args(argv)

	global listen_mode
	listen_mode = True

	global enable_host
	enable_host = args.enable_host

	global enable_port
	enable_port = args.enable_port

	global enable_execute
	enable_execute = args.enable_execute

	global line_separator
	line_separator = '\t'

	try:
		server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		server_socket.bind((args.address, args.port))
		server_socket.listen(10)
	except socket.error as e:
		raise FatalError(str(e).lower(), ERROR_SOCKET_ERROR)
	except Exception as e:
		raise FatalError(str(e).lower(), ERROR_OTHER_EXCEPTION)

	def client_loop():
		pending_data = ''

		try:
			client_socket, client_address = server_socket.accept()
		except socket.error:
			return

		print('{0} connected'.format(client_address[0]))

		while True:
			try:
				data = client_socket.recv(1024)
			except socket.error as e:
				print('{0} disconnected by socket error: {1}'.format(client_address[0], str(e).lower()))
				return
			except Exception as e:
				print('{0} disconnected by exception: {1}'.format(client_address[0], str(e).lower()))
				return

			if len(data) == 0:
				print('{0} disconnected'.format(client_address[0]))
				return

			if sys.hexversion >= 0x03000000:
				try:
					data = data.decode('utf-8')
				except UnicodeDecodeError as e:
					print('{0} sent invalid utf-8 data, disconnecting: {1}'.format(client_address[0], str(e).lower()))
					return

			pending_data += data

			while len(pending_data) > 0:
				i = pending_data.find(group_terminator)

				if i < 0:
					break

				command = pending_data[:i]
				pending_data = pending_data[i + len(group_terminator):]

				print('{0} sent {1}'.format(client_address[0], repr(command + group_terminator)))

				client_ctx = ctx.duplicate()

				def output_to_socket(string):
					if client_ctx.abort:
						return

					if sys.hexversion >= 0x03000000:
						try:
							string = string.encode('utf-8')
						except UnicodeDecodeError as e:
							print('utf-8 encoding error while sending {0} to {1}, disconnecting: {2}'.format(repr(string), client_address[0], str(e).lower()))

							client_ctx.abort = True
							return

					try:
						client_socket.sendall(string)
					except socket.error as e:
						print('socket error while sending {0} to {1}, disconnecting: {2}'.format(repr(string), client_address[0], str(e).lower()))

						client_ctx.abort = True
						return
					except Exception as e:
						print('exception while sending {0} to {1}, disconnecting: {2}'.format(repr(string), client_address[0], str(e).lower()))

						client_ctx.abort = True
						return

					print('{0} sent to {1}'.format(repr(string), client_address[0]))

				client_ctx.output = output_to_socket

				try:
					parse(client_ctx, shlex.split(command))
				except ParserExit:
					pass
				except FatalError as e:
					output_to_socket('error {0}: {1}{2}'.format(e.exit_code, e.message, group_terminator))

				if client_ctx.abort:
					return

	while True:
		ready, _, _ = select.select([server_socket], [], [])

		if server_socket not in ready:
			continue

		try:
			client_thread = threading.Thread(name='Client-Processor', target=client_loop)
			client_thread.daemon = True
			client_thread.start()
		except Exception as e:
			raise FatalError(str(e).lower(), ERROR_OTHER_EXCEPTION)

def parse(ctx, argv):
	global dry_run
	dry_run = os.getenv('TINKERFORGE_SHELL_BINDINGS_DRY_RUN', 0) != 0

	if listen_mode:
		prefix = ''
	else:
		prefix = 'tinkerforge '

	parser = Parser(ctx, '', epilog="Try '{0}<command> --help' for command specific help.".format(prefix))
	command_choices = ['call', 'dispatch', 'enumerate']

	if not listen_mode:
		command_choices.append('listen')

	if ctx.host is not None:
		host_default = ctx.host
	else:
		host_default = 'localhost'

	if ctx.port is not None:
		port_default = ctx.port
	else:
		port_default = 4223

	if ctx.item_separator is not None:
		item_separator_default = ctx.item_separator
	else:
		item_separator_default = ','

	if item_separator_default == ',':
		item_separator_help_suffix = ' (comma)'
	else:
		item_separator_help_suffix = ''

	if ctx.no_symbolic_input is not None:
		no_symbolic_input_default = ctx.no_symbolic_input
	else:
		no_symbolic_input_default = False

	if ctx.no_symbolic_output is not None:
		no_symbolic_output_default = ctx.no_symbolic_output
	else:
		no_symbolic_output_default = False

	namespace = argparse.Namespace()

	parser.add_argument('--version', action='version', version='2.1.4')

	if enable_host:
		parser.add_argument('--host', default=host_default, type=str, help='IP address or hostname to connect to, default: {0}'.format(host_default), metavar='<host>')
	else:
		setattr(namespace, 'host', host_default)

	if enable_port:
		parser.add_argument('--port', default=port_default, type=convert_int, help='port number to connect to, default: {0}'.format(port_default), metavar='<port>')
	else:
		setattr(namespace, 'port', port_default)

	parser.add_argument('--secret', default='', type=str, help='secret for authentication', metavar='<secret>')
	parser.add_argument('--item-separator', default=item_separator_default, type=str, help='separator for array items, default: {0}{1}'.format(item_separator_default, item_separator_help_suffix), metavar='<item-separator>')

	if not listen_mode:
		parser.add_argument('--group-separator', default='\n', type=str, help='separator for output groups, default: \\n (newline)', metavar='<group-separator>')
	else:
		setattr(namespace, 'group_separator', '\n')

	parser.add_argument('--no-symbolic-input', const=True, default=no_symbolic_input_default, action='store_const', help='disable symbolic input of values')
	parser.add_argument('--no-symbolic-output', const=True, default=no_symbolic_output_default, action='store_const', help='disable symbolic output of values')

	parser.add_argument('command', choices=command_choices, help='{' + ', '.join(command_choices) + '}', metavar='<command>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='command specific arguments', metavar='<args>')

	args = parser.parse_args(argv, namespace)

	ctx.host = args.host
	ctx.port = args.port
	ctx.secret = args.secret

	ctx.item_separator = args.item_separator
	ctx.item_separator = ctx.item_separator.replace('\\t', '\t')
	ctx.item_separator = ctx.item_separator.replace('\\r', '\r')
	ctx.item_separator = ctx.item_separator.replace('\\n', '\n')
	ctx.item_separator = ctx.item_separator.replace('\\\\', '\\')

	ctx.group_separator = args.group_separator
	ctx.group_separator = ctx.group_separator.replace('\\t', '\t')
	ctx.group_separator = ctx.group_separator.replace('\\r', '\r')
	ctx.group_separator = ctx.group_separator.replace('\\n', '\n')
	ctx.group_separator = ctx.group_separator.replace('\\\\', '\\')

	ctx.no_symbolic_input = args.no_symbolic_input
	ctx.no_symbolic_output = args.no_symbolic_output

	commands = {
	'call': command_call,
	'dispatch': command_dispatch,
	'enumerate': command_enumerate
	}

	if not listen_mode:
		commands['listen'] = command_listen

	commands[args.command](ctx, args.args)

def terminate(signal=None, frame=None):
	sys.exit(ERROR_INTERRUPTED)

def main():
	signal.signal(signal.SIGINT, terminate)
	signal.signal(signal.SIGTERM, terminate)

	ctx = Context()

	try:
		parse(ctx, sys.argv[1:])
	except KeyboardInterrupt:
		sys.exit(ERROR_INTERRUPTED)
	except ParserExit:
		sys.exit(0)
	except FatalError as e:
		if ctx.current_parser is not None:
			prog = ctx.current_parser.prog
		else:
			prog = 'tinkerforge'

		sys.stderr.write('{0}: error: {1}\n'.format(prog, e.message))
		sys.exit(e.exit_code)

if __name__ == '__main__':
	main()
